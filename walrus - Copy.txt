//optimization in c input is regular ecxpression
//input:
Enter number of regular expressions: 4
Enter regular expression 1 (a-z, +, -, |, *, parentheses; +, -, | all mean alternation): a+b
Enter regular expression 2 (a-z, +, -, |, *, parentheses; +, -, | all mean alternation): (a+b)*c
Enter regular expression 3 (a-z, +, -, |, *, parentheses; +, -, | all mean alternation): a-(b+c)
Enter regular expression 4 (a-z, +, -, |, *, parentheses; +, -, | all mean alternation): (a+b)-(c+d)
//if you want quadruple inputs there is another optim code in the file
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_TOKENS 100
#define MAX_TAC 200
#define MAX_QUADS 200
#define MAX_STR 32

// Node types for regex syntax tree
typedef enum { CHAR, CONCAT, UNION, STAR } NodeType;

// Syntax tree node
typedef struct RegexNode {
    NodeType type;
    char value; // valid if type == CHAR
    struct RegexNode *left, *right;
} RegexNode;

// TAC and Quadruple structures
typedef struct {
    char op[MAX_STR];
    char arg1[MAX_STR];
    char arg2[MAX_STR];
    char result[MAX_STR];
} Quadruple;

// Globals for TAC/Quadruple generation
char tac[MAX_TAC][MAX_STR];
int tac_count = 0;
Quadruple quads[MAX_QUADS];
int quad_count = 0;
int temp_var = 0;

// For combining all quadruples from all regexes
typedef struct {
    char op[MAX_STR];
    char arg1[MAX_STR];
    char arg2[MAX_STR];
    char result[MAX_STR];
} CombinedQuadruple;
CombinedQuadruple combined_quads[MAX_QUADS * 10];
int combined_quad_count = 0;

// --- Optimizer Functions (from 3.c) ---

// Add eliminated field to Quadruple for optimization
typedef struct OptQuadruple {
    char op[MAX_STR];
    char arg1[MAX_STR];
    char arg2[MAX_STR];
    char result[MAX_STR];
    bool eliminated;
} OptQuadruple;

OptQuadruple quad_list[MAX_QUADS];
int opt_quad_count = 0;

bool isConstant(const char *s) {
    if(s == NULL || *s == '\0' || strcmp(s, "") == 0) return false;
    int i = 0;
    if(s[0]=='-' || s[0]=='+') { if (s[1] == '\0') return false; i++; }
    for(; s[i] != '\0'; i++) if(!isdigit(s[i])) return false;
    return i > 0 && s[i-1] != '-' && s[i-1] != '+';
}

void printOptQuads(const char* title) {
    printf("\n--- %s ---\n", title);
    printf("Nr | %-10s | %-10s | %-10s | %-10s | %s\n", "Op", "Arg1", "Arg2", "Result", "Status");
    printf("---|------------|------------|------------|------------|--------\n");
    int displayed_count = 0;
    for (int i = 0; i < opt_quad_count; i++) {
        if (!quad_list[i].eliminated) {
            displayed_count++;
            printf("%03d| %-10s | %-10s | %-10s | %-10s | %s\n", i+1, quad_list[i].op, quad_list[i].arg1, quad_list[i].arg2, quad_list[i].result, "");
        }
    }
    if (displayed_count == 0) printf("(No quads remaining after optimization)\n");
    printf("-------------------------------------------------------------\n");
}

void commonSubexpressionElimination() {
    printf("\nPerforming Common Subexpression Elimination...\n");
    bool eliminated_found = false;
    for (int i = 0; i < opt_quad_count; i++) {
        if (quad_list[i].eliminated) continue;
        if (strcmp(quad_list[i].op, "=") == 0) continue;
        for (int j = 0; j < i; j++) {
            if (quad_list[j].eliminated) continue;
            if (strcmp(quad_list[j].op, "=") == 0) continue;
            if (strcmp(quad_list[i].op, quad_list[j].op) == 0 && strcmp(quad_list[i].arg1, quad_list[j].arg1) == 0 && strcmp(quad_list[i].arg2, quad_list[j].arg2) == 0) {
                printf("  Found potential CSE: Quad %d (%s %s %s %s) same as Quad %d (%s %s %s %s)\n", i+1, quad_list[i].op, quad_list[i].arg1, quad_list[i].arg2, quad_list[i].result, j+1, quad_list[j].op, quad_list[j].arg1, quad_list[j].arg2, quad_list[j].result);
                printf("    Eliminating Quad %d. Uses of '%s' should be replaced by '%s'\n", i+1, quad_list[i].result, quad_list[j].result);
                quad_list[i].eliminated = true;
                eliminated_found = true;
                break;
            }
        }
    }
    if (!eliminated_found) printf("  No common subexpressions identified for elimination.\n");
    printf("----------------------------------------\n");
}

void constantFoldingOptimization() {
    printf("\nPerforming Constant Folding...\n");
    bool changed = false;
    char buffer[MAX_STR];
    char orig_arg1[MAX_STR], orig_arg2[MAX_STR], orig_op[20];
    for (int i = 0; i < opt_quad_count; i++) {
        strcpy(orig_arg1, quad_list[i].arg1); strcpy(orig_arg2, quad_list[i].arg2); strcpy(orig_op, quad_list[i].op);
        if ((strcmp(quad_list[i].op, "+") == 0 || strcmp(quad_list[i].op, "-") == 0 || strcmp(quad_list[i].op, "*") == 0 || strcmp(quad_list[i].op, "/") == 0) && isConstant(quad_list[i].arg1) && isConstant(quad_list[i].arg2)) {
            int c1 = atoi(quad_list[i].arg1); int c2 = atoi(quad_list[i].arg2);
            if (strcmp(quad_list[i].op, "/") == 0 && c2 == 0) { continue; }
            int result_val = 0;
            if (strcmp(quad_list[i].op, "+") == 0) result_val = c1 + c2;
            else if (strcmp(quad_list[i].op, "-") == 0) result_val = c1 - c2;
            else if (strcmp(quad_list[i].op, "*") == 0) result_val = c1 * c2;
            else if (strcmp(quad_list[i].op, "/") == 0) result_val = c1 / c2;
            sprintf(buffer, "%d", result_val);
            printf("  Folding Quad %d (%s = %s %s %s) -> (%s = %s)\n", i+1, quad_list[i].result, orig_arg1, orig_op, orig_arg2, quad_list[i].result, buffer);
            strcpy(quad_list[i].op, "="); strcpy(quad_list[i].arg1, buffer); quad_list[i].arg2[0] = '\0';
            changed = true;
        }
    }
    if (!changed) printf("  No constant folding opportunities found.\n");
    printf("----------------------------------------\n");
}

void constantPropagationOptimization() {
    printf("\nPerforming Constant Propagation (and Folding)...\n");
    bool changed_prop = false;
    bool changed_fold = false;
    for (int i = 0; i < opt_quad_count; i++) {
        if (strcmp(quad_list[i].op, "=") == 0 && isConstant(quad_list[i].arg1) && quad_list[i].arg2[0] == '\0') {
            char* var_to_prop = quad_list[i].result;
            char* const_val = quad_list[i].arg1;
            if (strlen(var_to_prop) == 0) continue;
            for (int j = i + 1; j < opt_quad_count; j++) {
                bool propagated_here = false;
                if ((strcmp(quad_list[j].op, "+") == 0 || strcmp(quad_list[j].op, "-") == 0 || strcmp(quad_list[j].op, "*") == 0 || strcmp(quad_list[j].op, "/") == 0) && strcmp(quad_list[j].arg1, var_to_prop) == 0) {
                    strcpy(quad_list[j].arg1, const_val); propagated_here = true;
                }
                if ((strcmp(quad_list[j].op, "+") == 0 || strcmp(quad_list[j].op, "-") == 0 || strcmp(quad_list[j].op, "*") == 0 || strcmp(quad_list[j].op, "/") == 0) && strcmp(quad_list[j].arg2, var_to_prop) == 0) {
                    strcpy(quad_list[j].arg2, const_val); propagated_here = true;
                }
                if (propagated_here) {
                    printf("  Propagated '%s = %s' from Quad %d into Quad %d\n", var_to_prop, const_val, i+1, j+1);
                    changed_prop = true;
                }
            }
        }
    }
    if (!changed_prop) printf("  No constant propagation opportunities found.\n");
    printf("  Running follow-up Constant Folding...\n");
    char buffer[MAX_STR]; char orig_arg1[MAX_STR], orig_arg2[MAX_STR], orig_op[20];
    for (int i = 0; i < opt_quad_count; i++) {
        strcpy(orig_arg1, quad_list[i].arg1); strcpy(orig_arg2, quad_list[i].arg2); strcpy(orig_op, quad_list[i].op);
        if ((strcmp(quad_list[i].op, "+") == 0 || strcmp(quad_list[i].op, "-") == 0 || strcmp(quad_list[i].op, "*") == 0 || strcmp(quad_list[i].op, "/") == 0) && isConstant(quad_list[i].arg1) && isConstant(quad_list[i].arg2)) {
            int c1 = atoi(quad_list[i].arg1); int c2 = atoi(quad_list[i].arg2);
            if (strcmp(quad_list[i].op, "/") == 0 && c2 == 0) { continue; }
            int result_val = 0;
            if (strcmp(quad_list[i].op, "+") == 0) result_val = c1 + c2;
            else if (strcmp(quad_list[i].op, "-") == 0) result_val = c1 - c2;
            else if (strcmp(quad_list[i].op, "*") == 0) result_val = c1 * c2;
            else if (strcmp(quad_list[i].op, "/") == 0) result_val = c1 / c2;
            sprintf(buffer, "%d", result_val);
            printf("    Folding Quad %d (%s = %s %s %s) -> (%s = %s)\n", i+1, quad_list[i].result, orig_arg1, orig_op, orig_arg2, quad_list[i].result, buffer);
            strcpy(quad_list[i].op, "="); strcpy(quad_list[i].arg1, buffer); quad_list[i].arg2[0] = '\0';
            changed_fold = true;
        }
    }
    if (!changed_fold) printf("    No further folding opportunities found.\n");
    printf("----------------------------------------\n");
}

void deadCodeElimination() {
    printf("\nPerforming Dead Code Elimination...\n");
    bool changed = false;
    bool used[MAX_QUADS] = {false};
    for (int i = 0; i < opt_quad_count; i++) {
        if (quad_list[i].eliminated) continue;
        if (strlen(quad_list[i].arg1) > 0) {
            for (int j = 0; j < opt_quad_count; j++) {
                if (strcmp(quad_list[j].result, quad_list[i].arg1) == 0) used[j] = true;
            }
        }
        if (strlen(quad_list[i].arg2) > 0) {
            for (int j = 0; j < opt_quad_count; j++) {
                if (strcmp(quad_list[j].result, quad_list[i].arg2) == 0) used[j] = true;
            }
        }
    }
    for (int i = 0; i < opt_quad_count; i++) {
        if (quad_list[i].eliminated) continue;
        if (strlen(quad_list[i].result) > 0 && !used[i]) {
            quad_list[i].eliminated = true;
            changed = true;
            printf("  Eliminated dead code at Quad %d (%s %s %s %s)\n", i+1, quad_list[i].op, quad_list[i].arg1, quad_list[i].arg2, quad_list[i].result);
        }
    }
    if (!changed) printf("  No dead code found.\n");
    printf("----------------------------------------\n");
}

void copyPropagation() {
    printf("\nPerforming Copy Propagation...\n");
    bool changed = false;
    for (int i = 0; i < opt_quad_count; i++) {
        if (quad_list[i].eliminated) continue;
        if (strcmp(quad_list[i].op, "=") == 0 && strlen(quad_list[i].arg1) > 0 && strlen(quad_list[i].arg2) == 0) {
            char* src = quad_list[i].arg1;
            char* dest = quad_list[i].result;
            for (int j = i + 1; j < opt_quad_count; j++) {
                if (quad_list[j].eliminated) continue;
                if (strcmp(quad_list[j].arg1, dest) == 0) {
                    strcpy(quad_list[j].arg1, src);
                    changed = true;
                    printf("  Propagated copy from Quad %d to Quad %d (arg1)\n", i+1, j+1);
                }
                if (strcmp(quad_list[j].arg2, dest) == 0) {
                    strcpy(quad_list[j].arg2, src);
                    changed = true;
                    printf("  Propagated copy from Quad %d to Quad %d (arg2)\n", i+1, j+1);
                }
            }
        }
    }
    if (!changed) printf("  No copy propagation opportunities found.\n");
    printf("----------------------------------------\n");
}

// --- Regex Parsing ---
// Forward declarations
RegexNode* parse_regex(const char **s);
RegexNode* parse_term(const char **s);
RegexNode* parse_factor(const char **s);

// Utility: create a new node
RegexNode* new_node(NodeType type, char value, RegexNode* left, RegexNode* right) {
    RegexNode* n = (RegexNode*)malloc(sizeof(RegexNode));
    n->type = type; n->value = value; n->left = left; n->right = right;
    return n;
}

// Parse factor: CHAR or (regex) or factor*
RegexNode* parse_factor(const char **s) {
    if (**s == '(') {
        (*s)++;
        RegexNode* n = parse_regex(s);
        if (**s == ')') (*s)++;
        // Handle star
        if (**s == '*') { (*s)++; n = new_node(STAR, 0, n, NULL); }
        return n;
    } else if ((**s >= 'a' && **s <= 'z') || (**s >= 'A' && **s <= 'Z')) {
        RegexNode* n = new_node(CHAR, **s, NULL, NULL);
        (*s)++;
        // Handle star
        if (**s == '*') { (*s)++; n = new_node(STAR, 0, n, NULL); }
        return n;
    }
    return NULL;
}

// Parse term: factor (factor ...)
RegexNode* parse_term(const char **s) {
    RegexNode* left = parse_factor(s);
    while (**s && **s != ')' && **s != '|') {
        RegexNode* right = parse_factor(s);
        left = new_node(CONCAT, 0, left, right);
    }
    return left;
}

// Parse regex: term ('|' term)*
RegexNode* parse_regex(const char **s) {
    RegexNode* left = parse_term(s);
    while (**s == '|' || **s == '+' || **s == '-') {
        (*s)++;
        RegexNode* right = parse_term(s);
        left = new_node(UNION, 0, left, right);
    }
    return left;
}

// --- TAC Generation ---
// Returns the name of the result temp variable
char* gen_TAC(RegexNode* node) {
    static char buf[MAX_STR];
    if (!node) return NULL;
    if (node->type == CHAR) {
        snprintf(buf, MAX_STR, "'%c'", node->value);
        return buf;
    }
    char left[MAX_STR], right[MAX_STR];
    char *l = NULL, *r = NULL;
    if (node->left) l = gen_TAC(node->left);
    if (node->right) r = gen_TAC(node->right);
    char t[MAX_STR];
    snprintf(t, MAX_STR, "t%d", temp_var++);
    if (node->type == CONCAT) {
        snprintf(tac[tac_count++], MAX_STR, "%s = CONCAT %s %s", t, l, r);
    } else if (node->type == UNION) {
        snprintf(tac[tac_count++], MAX_STR, "%s = UNION %s %s", t, l, r);
    } else if (node->type == STAR) {
        snprintf(tac[tac_count++], MAX_STR, "%s = STAR %s", t, l);
    }
    strcpy(buf, t);
    return buf;
}

// --- TAC to Quadruple ---
void tac_to_quads() {
    quad_count = 0;
    for (int i = 0; i < tac_count; i++) {
        char op[MAX_STR], arg1[MAX_STR], arg2[MAX_STR], result[MAX_STR];
        int n = sscanf(tac[i], "%s = %s %s %s", result, op, arg1, arg2);
        if (n == 4) {
            strcpy(quads[quad_count].op, op);
            strcpy(quads[quad_count].arg1, arg1);
            strcpy(quads[quad_count].arg2, arg2);
            strcpy(quads[quad_count].result, result);
        } else if (n == 3) {
            strcpy(quads[quad_count].op, op);
            strcpy(quads[quad_count].arg1, arg1);
            quads[quad_count].arg2[0] = '\0';
            strcpy(quads[quad_count].result, result);
        }
        quad_count++;
    }
}

// --- Print Functions ---
void print_TAC() {
    printf("\n--- TAC ---\n");
    for (int i = 0; i < tac_count; i++) printf("%s\n", tac[i]);
}
void print_quads() {
    printf("\n--- Quadruples ---\n");
    printf("%-10s | %-10s | %-10s | %-10s\n", "Op", "Arg1", "Arg2", "Result");
    for (int i = 0; i < quad_count; i++) {
        printf("%-10s | %-10s | %-10s | %-10s\n", quads[i].op, quads[i].arg1, quads[i].arg2, quads[i].result);
    }
}

// --- Main ---
int main() {
    int n;
    printf("Enter number of regular expressions: ");
    scanf("%d", &n);
    getchar(); // consume newline
    quad_count = 0; // combined quadruple count
    combined_quad_count = 0;
    for (int i = 0; i < n; i++) {
        char regex[128];
        printf("Enter regular expression %d (a-z, +, -, |, *, parentheses; +, -, | all mean alternation): ", i+1);
        scanf("%127s", regex);
        const char* p = regex;
        RegexNode* root = parse_regex(&p);
        if (*p != '\0') { printf("Parse error at: %s\n", p); continue; }
        tac_count = 0; temp_var = 0;
        gen_TAC(root);
        tac_to_quads();
        for (int k = 0; k < quad_count; k++) {
            combined_quads[combined_quad_count].op[0] = '\0';
            strcpy(combined_quads[combined_quad_count].op, quads[k].op);
            strcpy(combined_quads[combined_quad_count].arg1, quads[k].arg1);
            strcpy(combined_quads[combined_quad_count].arg2, quads[k].arg2);
            strcpy(combined_quads[combined_quad_count].result, quads[k].result);
            combined_quad_count++;
        }
        quad_count = 0;
    }
    opt_quad_count = combined_quad_count;
    for (int k = 0; k < opt_quad_count; k++) {
        strcpy(quad_list[k].op, combined_quads[k].op);
        strcpy(quad_list[k].arg1, combined_quads[k].arg1);
        strcpy(quad_list[k].arg2, combined_quads[k].arg2);
        strcpy(quad_list[k].result, combined_quads[k].result);
        quad_list[k].eliminated = false;
    }
    // Print all quadruples before optimization
    printf("\n--- Combined Quadruples Before Optimization ---\n");
    printf("Nr | %-10s | %-10s | %-10s | %-10s\n", "Op", "Arg1", "Arg2", "Result");
    printf("---|------------|------------|------------|------------\n");
    for (int i = 0; i < opt_quad_count; i++) {
        printf("%03d| %-10s | %-10s | %-10s | %-10s\n", i+1, quad_list[i].op, quad_list[i].arg1, quad_list[i].arg2, quad_list[i].result);
    }
    int option = 0;
    while (option < 1 || option > 5) {
        printf("\nSelect optimization technique for all expressions:\n");
        printf("  1. Common Subexpression Elimination (CSE)\n");
        printf("  2. Constant Folding\n");
        printf("  3. Constant Propagation (includes Folding)\n");
        printf("  4. Dead Code Elimination\n");
        printf("  5. Copy Propagation\n");
        printf("Enter your choice (1-5): ");
        scanf("%d", &option);
        if (option < 1 || option > 5) {
            printf("Invalid choice. Please enter 1, 2, 3, 4, or 5.\n");
            option = 0;
        }
    }
    switch(option) {
        case 1:
            commonSubexpressionElimination();
            break;
        case 2:
            constantFoldingOptimization();
            break;
        case 3:
            constantPropagationOptimization();
            break;
        case 4:
            deadCodeElimination();
            break;
        case 5:
            copyPropagation();
            break;
    }
    printOptQuads("Optimized Quadruples");
    return 0;
} 


//optimization in c 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#define MAX_QUADS 500
#define MAX_STR 100
#define MAX_BLOCKS 100


typedef struct {
    char op[20];
    char arg1[MAX_STR];
    char arg2[MAX_STR];
    char result[MAX_STR];
    bool eliminated; 
    bool is_leader; 
} Quadruple;


typedef struct {
    int start_quad; 
    int end_quad;   
    int successors[2]; 
    int num_successors;
} BasicBlock;


Quadruple quad_list[MAX_QUADS];
int quad_count = 0;
BasicBlock blocks[MAX_BLOCKS];
int block_count = 0;


bool readQuadsFromFile(const char* filename);
void printQuads(const char* title, bool show_eliminated);
void identifyBasicBlocks();
void printBasicBlocks();
void printControlFlowGraph();


void commonSubexpressionElimination();
void constantFoldingOptimization(); 
void constantPropagationOptimization(); 
void deadCodeElimination();
void copyPropagation();

bool isConstant(const char *s);
int evaluateExpression(const char *op, int c1, int c2);


bool readQuadsFromFile(const char* filename) {
    FILE* fp = fopen(filename, "r");
    if (!fp) {
        perror("Error opening Quad input file");
        return false;
    }
    printf("Reading Quads from %s...\n", filename);
    quad_count = 0;
    char line[100]; // Use MAX_LINE defined earlier

    while (fgets(line, sizeof(line), fp) && quad_count < MAX_QUADS) {
        line[strcspn(line, "\r\n")] = 0; // Remove trailing newline
        if (strlen(line) == 0) continue; // Skip empty lines

        char* parts[4] = {NULL, NULL, NULL, NULL}; // Pointers to parts within the line buffer
        char* current_pos = line;
        int part_index = 0;

        
        while(part_index < 4 && current_pos != NULL && *current_pos != '\0') {
             parts[part_index++] = current_pos;
             char* next_space = strchr(current_pos, ' ');
             if (next_space != NULL) {
                 *next_space = '\0';
                 current_pos = next_space + 1; // Move to the start of the next part
             } else {
                 // This is the last part
                 current_pos = NULL; // Stop the loop
             }
        }

     
        if (parts[0]) { // Op must exist
            strncpy(quad_list[quad_count].op, parts[0], 19);
            quad_list[quad_count].op[19] = '\0';

            strncpy(quad_list[quad_count].arg1, (parts[1] && strcmp(parts[1], "-") != 0) ? parts[1] : "", MAX_STR - 1);
            quad_list[quad_count].arg1[MAX_STR - 1] = '\0';

            strncpy(quad_list[quad_count].arg2, (parts[2] && strcmp(parts[2], "-") != 0) ? parts[2] : "", MAX_STR - 1);
            quad_list[quad_count].arg2[MAX_STR - 1] = '\0';

            strncpy(quad_list[quad_count].result, (parts[3] && strcmp(parts[3], "-") != 0) ? parts[3] : "", MAX_STR - 1);
            quad_list[quad_count].result[MAX_STR - 1] = '\0';

            quad_list[quad_count].eliminated = false;
            quad_list[quad_count].is_leader = false;
            quad_count++;
        } else {
             fprintf(stderr, "Warning: Skipping malformed quad line (empty?): %s\n", line);
        }
    }

    fclose(fp);
    printf("Read %d quads.\n", quad_count);
    return true;
}

void printQuads(const char* title, bool show_eliminated) {
    printf("\n--- %s ---\n", title);
    printf("Nr | %-15s | %-25s | %-25s | %-25s | %s\n", "Op", "Arg1", "Arg2", "Result", show_eliminated ? "Status" : "");
    printf("---|-----------------|---------------------------|---------------------------|---------------------------|--------\n");
    if (quad_count == 0) {
        printf("(No Quads)\n");
    }
    int displayed_count = 0;
    for (int i = 0; i < quad_count; i++) {
        if (!quad_list[i].eliminated || show_eliminated) {
            displayed_count++;
             printf("%03d| %-15s | %-25s | %-25s | %-25s | %s\n", i + 1,
                   quad_list[i].op, quad_list[i].arg1, quad_list[i].arg2, quad_list[i].result,
                   show_eliminated ? (quad_list[i].eliminated ? "(Elim)" : "") : "");
        }
    }
    if (displayed_count == 0 && !show_eliminated) {
         printf("(No quads remaining after optimization)\n");
    }
    printf("-----------------------------------------------------------------------------------------------\n");
}



void identifyBasicBlocks() {
    if (quad_count == 0) return;

 
    block_count = 0;

 
    quad_list[0].is_leader = true;

   

    int current_block_start = -1;
    for (int i = 0; i < quad_count; i++) {
        if (quad_list[i].is_leader) {
            // End the previous block if one was started
            if (current_block_start != -1 && block_count > 0) {
                blocks[block_count - 1].end_quad = i - 1;
            }
            // Start a new block
            if (block_count < MAX_BLOCKS) {
                blocks[block_count].start_quad = i;
                blocks[block_count].num_successors = 0; // Initialize successors
                current_block_start = i;
                block_count++;
            } else {
                fprintf(stderr, "Error: Maximum number of basic blocks exceeded.\n");
                return;
            }
        }
    }

    if (block_count > 0) {
        blocks[block_count - 1].end_quad = quad_count - 1;
    }
     printf("Found %d basic block(s).\n", block_count);
}

void printBasicBlocks() {
    printf("\n--- Basic Blocks ---\n");
    for(int i=0; i<block_count; ++i) {
        printf("Block B%d: Quads %d to %d\n", i, blocks[i].start_quad + 1, blocks[i].end_quad + 1);
    
        for (int q = blocks[i].start_quad; q <= blocks[i].end_quad; ++q) {
             printf("  %03d| %s %s %s %s\n", q + 1,
                   quad_list[q].op, quad_list[q].arg1, quad_list[q].arg2, quad_list[q].result);
        }
    }
     printf("---------------------\n");
}

void printControlFlowGraph() {
     printf("\n--- Control Flow Graph (Simplified) ---\n");

     if (block_count == 0) {
         printf("(No blocks)\n");
     }
     for(int i=0; i<block_count; ++i) {
        printf("Block B%d:", i);

        if (i + 1 < block_count) { 
             printf(" -> B%d (sequential)", i + 1);
     
        } else {
             printf(" -> END"); // Last block exits
        }
        printf("\n");
     }
      printf("---------------------------------------\n");
}


void commonSubexpressionElimination() {
    printf("\nPerforming Common Subexpression Elimination...\n");
    bool eliminated_found = false;
    for (int i = 0; i < quad_count; i++) {
        if (quad_list[i].eliminated) continue;

        // Skip assignment operations
        if (strcmp(quad_list[i].op, "=") == 0) continue;

        for (int j = 0; j < i; j++) {
            if (quad_list[j].eliminated) continue;
            if (strcmp(quad_list[j].op, "=") == 0) continue;

            if (strcmp(quad_list[i].op, quad_list[j].op) == 0 &&
                strcmp(quad_list[i].arg1, quad_list[j].arg1) == 0 &&
                strcmp(quad_list[i].arg2, quad_list[j].arg2) == 0)
            {
                printf("  Found potential CSE: Quad %d (%s %s %s %s) same as Quad %d (%s %s %s %s)\n",
                       i + 1, quad_list[i].op, quad_list[i].arg1, quad_list[i].arg2, quad_list[i].result,
                       j + 1, quad_list[j].op, quad_list[j].arg1, quad_list[j].arg2, quad_list[j].result);
                printf("    Eliminating Quad %d. Uses of '%s' should be replaced by '%s'\n",
                       i + 1, quad_list[i].result, quad_list[j].result);

                quad_list[i].eliminated = true;
                eliminated_found = true;
                break;
            }
        }
    }
    if (!eliminated_found) printf("  No common subexpressions identified for elimination.\n");
    printf("----------------------------------------\n");
}



bool isConstant(const char *s) {
    if(s == NULL || *s == '\0' || strcmp(s, "") == 0) return false;
    int i = 0;
    if(s[0]=='-' || s[0]=='+') { if (s[1] == '\0') return false; i++; }
    for(; s[i] != '\0'; i++) if(!isdigit(s[i])) return false;
    return i > 0 && s[i-1] != '-' && s[i-1] != '+'; 
}
int evaluateExpression(const char *op, int c1, int c2) {
    if(strcmp(op, "+") == 0) return c1 + c2;
    if(strcmp(op, "-") == 0) return c1 - c2;
    if(strcmp(op, "*") == 0) return c1 * c2;
    if(strcmp(op, "/") == 0) { if (c2 == 0) return 0; return c1 / c2; } // Basic div zero check
    return 0;
}


void constantFoldingOptimization() {
    printf("\nPerforming Constant Folding...\n");

    bool changed = false;
    char buffer[MAX_STR];
    char orig_arg1[MAX_STR], orig_arg2[MAX_STR], orig_op[20];

    for (int i = 0; i < quad_count; i++) {
        strcpy(orig_arg1, quad_list[i].arg1); strcpy(orig_arg2, quad_list[i].arg2); strcpy(orig_op, quad_list[i].op);

        if ((strcmp(quad_list[i].op, "+") == 0 || strcmp(quad_list[i].op, "-") == 0 ||
             strcmp(quad_list[i].op, "*") == 0 || strcmp(quad_list[i].op, "/") == 0) &&
            isConstant(quad_list[i].arg1) && isConstant(quad_list[i].arg2))
        {
            int c1 = atoi(quad_list[i].arg1); int c2 = atoi(quad_list[i].arg2);
            if (strcmp(quad_list[i].op, "/") == 0 && c2 == 0) { /* handle error */ continue; }
            int result_val = evaluateExpression(quad_list[i].op, c1, c2);
            sprintf(buffer, "%d", result_val);
            printf("  Folding Quad %d (%s = %s %s %s) -> (%s = %s)\n", i + 1,
                   quad_list[i].result, orig_arg1, orig_op, orig_arg2, quad_list[i].result, buffer);
            strcpy(quad_list[i].op, "="); strcpy(quad_list[i].arg1, buffer); quad_list[i].arg2[0] = '\0';
            changed = true;
        }
    }
    if (!changed) printf("  No constant folding opportunities found (expected for this IR).\n");
    printf("----------------------------------------\n");
}

void constantPropagationOptimization() {
     printf("\nPerforming Constant Propagation (and Folding)...\n");
  
     bool changed_prop = false;
     bool changed_fold = false;

     for (int i = 0; i < quad_count; i++) {
      
         if (strcmp(quad_list[i].op, "=") == 0 && isConstant(quad_list[i].arg1) && quad_list[i].arg2[0] == '\0') {
             char* var_to_prop = quad_list[i].result;
             char* const_val = quad_list[i].arg1;
             if (strlen(var_to_prop) == 0) continue; // Cannot propagate if result is empty

             for (int j = i + 1; j < quad_count; j++) {
                 bool propagated_here = false;
                 // Propagate into arg1 of arithmetic ops
                 if ((strcmp(quad_list[j].op, "+") == 0 || strcmp(quad_list[j].op, "-") == 0 ||
                      strcmp(quad_list[j].op, "*") == 0 || strcmp(quad_list[j].op, "/") == 0) &&
                     strcmp(quad_list[j].arg1, var_to_prop) == 0)
                 {
                     strcpy(quad_list[j].arg1, const_val); propagated_here = true;
                 }
                 // Propagate into arg2 of arithmetic ops
                 if ((strcmp(quad_list[j].op, "+") == 0 || strcmp(quad_list[j].op, "-") == 0 ||
                      strcmp(quad_list[j].op, "*") == 0 || strcmp(quad_list[j].op, "/") == 0) &&
                      strcmp(quad_list[j].arg2, var_to_prop) == 0)
                 {
                     strcpy(quad_list[j].arg2, const_val); propagated_here = true;
                 }
                  
                 if (propagated_here) {
                     printf("  Propagated '%s = %s' from Quad %d into Quad %d\n", var_to_prop, const_val, i + 1, j + 1);
                      changed_prop = true;
                 }
             }
         }
     }
      if (!changed_prop) printf("  No constant propagation opportunities found (expected for this IR).\n");

 
     printf("  Running follow-up Constant Folding...\n");

     char buffer[MAX_STR]; char orig_arg1[MAX_STR], orig_arg2[MAX_STR], orig_op[20];
     for (int i = 0; i < quad_count; i++) {
         strcpy(orig_arg1, quad_list[i].arg1); strcpy(orig_arg2, quad_list[i].arg2); strcpy(orig_op, quad_list[i].op);
         if ((strcmp(quad_list[i].op, "+") == 0 || strcmp(quad_list[i].op, "-") == 0 ||
              strcmp(quad_list[i].op, "*") == 0 || strcmp(quad_list[i].op, "/") == 0) &&
             isConstant(quad_list[i].arg1) && isConstant(quad_list[i].arg2)) {
             int c1 = atoi(quad_list[i].arg1); int c2 = atoi(quad_list[i].arg2);
             if (strcmp(quad_list[i].op, "/") == 0 && c2 == 0) { continue; }
             int result_val = evaluateExpression(quad_list[i].op, c1, c2); sprintf(buffer, "%d", result_val);
             printf("    Folding Quad %d (%s = %s %s %s) -> (%s = %s)\n", i + 1, quad_list[i].result, orig_arg1, orig_op, orig_arg2, quad_list[i].result, buffer);
             strcpy(quad_list[i].op, "="); strcpy(quad_list[i].arg1, buffer); quad_list[i].arg2[0] = '\0';
             changed_fold = true;
         }
     }
     if (!changed_fold) printf("    No further folding opportunities found.\n");
     printf("----------------------------------------\n");
}

void deadCodeElimination() {
    printf("\nPerforming Dead Code Elimination...\n");
    bool changed = false;
    // Mark all variables as not used
    bool used[MAX_QUADS] = {false};
    // Mark variables that are used as arguments in non-eliminated quads
    for (int i = 0; i < quad_count; i++) {
        if (quad_list[i].eliminated) continue;
        if (strlen(quad_list[i].arg1) > 0) {
            for (int j = 0; j < quad_count; j++) {
                if (strcmp(quad_list[j].result, quad_list[i].arg1) == 0) used[j] = true;
            }
        }
        if (strlen(quad_list[i].arg2) > 0) {
            for (int j = 0; j < quad_count; j++) {
                if (strcmp(quad_list[j].result, quad_list[i].arg2) == 0) used[j] = true;
            }
        }
    }
    // Eliminate assignments whose result is never used
    for (int i = 0; i < quad_count; i++) {
        if (quad_list[i].eliminated) continue;
        if (strlen(quad_list[i].result) > 0 && !used[i]) {
            quad_list[i].eliminated = true;
            changed = true;
            printf("  Eliminated dead code at Quad %d (%s %s %s %s)\n", i+1, quad_list[i].op, quad_list[i].arg1, quad_list[i].arg2, quad_list[i].result);
        }
    }
    if (!changed) printf("  No dead code found.\n");
    printf("----------------------------------------\n");
}

void copyPropagation() {
    printf("\nPerforming Copy Propagation...\n");
    bool changed = false;
    for (int i = 0; i < quad_count; i++) {
        if (quad_list[i].eliminated) continue;
        if (strcmp(quad_list[i].op, "=") == 0 && strlen(quad_list[i].arg1) > 0 && strlen(quad_list[i].arg2) == 0) {
            char* src = quad_list[i].arg1;
            char* dest = quad_list[i].result;
            for (int j = i + 1; j < quad_count; j++) {
                if (quad_list[j].eliminated) continue;
                if (strcmp(quad_list[j].arg1, dest) == 0) {
                    strcpy(quad_list[j].arg1, src);
                    changed = true;
                    printf("  Propagated copy from Quad %d to Quad %d (arg1)\n", i+1, j+1);
                }
                if (strcmp(quad_list[j].arg2, dest) == 0) {
                    strcpy(quad_list[j].arg2, src);
                    changed = true;
                    printf("  Propagated copy from Quad %d to Quad %d (arg2)\n", i+1, j+1);
                }
            }
        }
    }
    if (!changed) printf("  No copy propagation opportunities found.\n");
    printf("----------------------------------------\n");
}

int main(int argc, char *argv[]) {
    const char* quad_filename = "music_score1quads";

    if (argc > 1) {
        quad_filename = argv[1]; 
    }

    printf("--- Quadruple Optimizer ---\n");

    if (!readQuadsFromFile(quad_filename)) {
        fprintf(stderr, "Failed to read quadruples from %s. Exiting.\n", quad_filename);
        return 1;
    }
    printQuads("Initial Quads Loaded", false);

    int option = 0;
    while (option < 1 || option > 5) {
        printf("\nSelect optimization technique:\n");
        printf("  1. Common Subexpression Elimination (CSE)\n");
        printf("  2. Constant Folding\n");
        printf("  3. Constant Propagation (includes Folding)\n");
        printf("  4. Dead Code Elimination\n");
        printf("  5. Copy Propagation\n");
        printf("Enter your choice (1-5): ");
        if (scanf("%d", &option) != 1 || option < 1 || option > 5) {
            printf("Invalid choice. Please enter 1, 2, 3, 4, or 5.\n");
            while (getchar() != '\n');
            option = 0;
        }
    }

    switch(option) {
        case 1:
            commonSubexpressionElimination();
            break;
        case 2:
            constantFoldingOptimization();
            break;
        case 3:
            constantPropagationOptimization();
            break;
        case 4:
            deadCodeElimination();
            break;
        case 5:
            copyPropagation();
            break;
    }

    printQuads("Optimized Quadruples", false);
    return 0;
}
//steps to run 
//input is at end of all three optimization codes scroll below or sarch input optim
1] gcc name.c -o name
2] ./name input.txt

//optimization in c++
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <cstdlib>

using namespace std;

const int MAX_QUADS = 500;
const int MAX_STR = 100;

class Quadruple {
public:
    string op;
    string arg1;
    string arg2;
    string result;
    bool eliminated;
    bool is_leader;

    Quadruple() : eliminated(false), is_leader(false) {}
};

class QuadrupleOptimizer {
private:
    vector<Quadruple> quad_list;

    bool isConstant(const string& s) {
        if(s.empty()) return false;
        size_t start = (s[0] == '+' || s[0] == '-') ? 1 : 0;
        if(start == s.length()) return false;
        return s.find_first_not_of("0123456789", start) == string::npos;
    }

    int evaluateExpression(const string& op, int c1, int c2) {
        if(op == "+") return c1 + c2;
        if(op == "-") return c1 - c2;
        if(op == "*") return c1 * c2;
        if(op == "/") return c2 != 0 ? c1 / c2 : 0;
        return 0;
    }

public:
    bool readQuadsFromFile(const string& filename) {
        ifstream file(filename);
        if (!file.is_open()) {
            cerr << "Error opening Quad input file" << endl;
            return false;
        }
        cout << "Reading Quads from " << filename << "..." << endl;

        string line;
        while (getline(file, line) && quad_list.size() < MAX_QUADS) {
            if(line.empty()) continue;

            istringstream iss(line);
            Quadruple quad;
            iss >> quad.op;
            iss >> quad.arg1;
            iss >> quad.arg2;
            iss >> quad.result;

            if(quad.arg1 == "-") quad.arg1 = "";
            if(quad.arg2 == "-") quad.arg2 = "";
            if(quad.result == "-") quad.result = "";

            quad_list.push_back(quad);
        }

        file.close();
        cout << "Read " << quad_list.size() << " quads." << endl;
        return true;
    }

    void printQuads(const string& title, bool show_eliminated) {
        cout << "\n--- " << title << " ---" << endl;
        cout << "Nr | Op              | Arg1                      | Arg2                      | Result                    | " 
             << (show_eliminated ? "Status" : "") << endl;
        cout << "---|-----------------|---------------------------|---------------------------|---------------------------|--------" << endl;

        if (quad_list.empty()) {
            cout << "(No Quads)" << endl;
            return;
        }

        int displayed_count = 0;
        for (size_t i = 0; i < quad_list.size(); i++) {
            if (!quad_list[i].eliminated || show_eliminated) {
                displayed_count++;
                printf("%03d| %-15s | %-25s | %-25s | %-25s | %s\n", 
                       (int)i + 1,
                       quad_list[i].op.c_str(),
                       quad_list[i].arg1.c_str(),
                       quad_list[i].arg2.c_str(),
                       quad_list[i].result.c_str(),
                       show_eliminated ? (quad_list[i].eliminated ? "(Elim)" : "") : "");
            }
        }

        if (displayed_count == 0 && !show_eliminated) {
            cout << "(No quads remaining after optimization)" << endl;
        }
        cout << string(95, '-') << endl;
    }

    void commonSubexpressionElimination() {
        cout << "\nPerforming Common Subexpression Elimination..." << endl;
        bool eliminated_found = false;

        for (size_t i = 0; i < quad_list.size(); i++) {
            if (quad_list[i].eliminated) continue;
            if (quad_list[i].op == "=") continue;

            for (size_t j = 0; j < i; j++) {
                if (quad_list[j].eliminated) continue;
                if (quad_list[j].op == "=") continue;

                if (quad_list[i].op == quad_list[j].op &&
                    quad_list[i].arg1 == quad_list[j].arg1 &&
                    quad_list[i].arg2 == quad_list[j].arg2)
                {
                    cout << "  Found potential CSE: Quad " << i + 1 
                         << " (" << quad_list[i].op << " " << quad_list[i].arg1 << " " 
                         << quad_list[i].arg2 << " " << quad_list[i].result << ") same as Quad "
                         << j + 1 << " (" << quad_list[j].op << " " << quad_list[j].arg1 << " "
                         << quad_list[j].arg2 << " " << quad_list[j].result << ")" << endl;
                    cout << "    Eliminating Quad " << i + 1 << ". Uses of '" 
                         << quad_list[i].result << "' should be replaced by '" 
                         << quad_list[j].result << "'" << endl;

                    quad_list[i].eliminated = true;
                    eliminated_found = true;
                    break;
                }
            }
        }
        if (!eliminated_found) cout << "  No common subexpressions identified for elimination." << endl;
        cout << string(40, '-') << endl;
    }

    void constantFoldingOptimization() {
        cout << "\nPerforming Constant Folding..." << endl;
        bool changed = false;

        for (size_t i = 0; i < quad_list.size(); i++) {
            if ((quad_list[i].op == "+" || quad_list[i].op == "-" ||
                 quad_list[i].op == "*" || quad_list[i].op == "/") &&
                isConstant(quad_list[i].arg1) && isConstant(quad_list[i].arg2))
            {
                string orig_op = quad_list[i].op;
                string orig_arg1 = quad_list[i].arg1;
                string orig_arg2 = quad_list[i].arg2;

                int c1 = stoi(quad_list[i].arg1);
                int c2 = stoi(quad_list[i].arg2);

                if (quad_list[i].op == "/" && c2 == 0) continue;

                int result_val = evaluateExpression(quad_list[i].op, c1, c2);
                
                cout << "  Folding Quad " << i + 1 << " (" << quad_list[i].result 
                     << " = " << orig_arg1 << " " << orig_op << " " << orig_arg2 
                     << ") -> (" << quad_list[i].result << " = " << result_val << ")" << endl;

                quad_list[i].op = "=";
                quad_list[i].arg1 = to_string(result_val);
                quad_list[i].arg2 = "";
                changed = true;
            }
        }
        if (!changed) cout << "  No constant folding opportunities found." << endl;
        cout << string(40, '-') << endl;
    }

    void constantPropagationOptimization() {
        cout << "\nPerforming Constant Propagation (and Folding)..." << endl;
        bool changed_prop = false;
        bool changed_fold = false;

        // Constant Propagation
        for (size_t i = 0; i < quad_list.size(); i++) {
            if (quad_list[i].op == "=" && isConstant(quad_list[i].arg1) && quad_list[i].arg2.empty()) {
                string var_to_prop = quad_list[i].result;
                string const_val = quad_list[i].arg1;

                for (size_t j = i + 1; j < quad_list.size(); j++) {
                    bool propagated_here = false;
                    if ((quad_list[j].op == "+" || quad_list[j].op == "-" ||
                         quad_list[j].op == "*" || quad_list[j].op == "/")) {
                        
                        if (quad_list[j].arg1 == var_to_prop) {
                            quad_list[j].arg1 = const_val;
                            propagated_here = true;
                        }
                        if (quad_list[j].arg2 == var_to_prop) {
                            quad_list[j].arg2 = const_val;
                            propagated_here = true;
                        }
                    }
                    if (propagated_here) {
                        cout << "  Propagated '" << var_to_prop << " = " << const_val 
                             << "' from Quad " << i + 1 << " into Quad " << j + 1 << endl;
                        changed_prop = true;
                    }
                }
            }
        }
        if (!changed_prop) cout << "  No constant propagation opportunities found." << endl;

        // Follow-up Constant Folding
        cout << "  Running follow-up Constant Folding..." << endl;
        for (size_t i = 0; i < quad_list.size(); i++) {
            if ((quad_list[i].op == "+" || quad_list[i].op == "-" ||
                 quad_list[i].op == "*" || quad_list[i].op == "/") &&
                isConstant(quad_list[i].arg1) && isConstant(quad_list[i].arg2))
            {
                string orig_op = quad_list[i].op;
                string orig_arg1 = quad_list[i].arg1;
                string orig_arg2 = quad_list[i].arg2;

                int c1 = stoi(quad_list[i].arg1);
                int c2 = stoi(quad_list[i].arg2);

                if (quad_list[i].op == "/" && c2 == 0) continue;

                int result_val = evaluateExpression(quad_list[i].op, c1, c2);
                
                cout << "    Folding Quad " << i + 1 << " (" << quad_list[i].result 
                     << " = " << orig_arg1 << " " << orig_op << " " << orig_arg2 
                     << ") -> (" << quad_list[i].result << " = " << result_val << ")" << endl;

                quad_list[i].op = "=";
                quad_list[i].arg1 = to_string(result_val);
                quad_list[i].arg2 = "";
                changed_fold = true;
            }
        }
        if (!changed_fold) cout << "    No further folding opportunities found." << endl;
        cout << string(40, '-') << endl;
    }

    void deadCodeElimination() {
        cout << "\nPerforming Dead Code Elimination..." << endl;
        bool changed = false;
        vector<bool> used(quad_list.size(), false);
        // Mark variables that are used as arguments in non-eliminated quads
        for (size_t i = 0; i < quad_list.size(); i++) {
            if (quad_list[i].eliminated) continue;
            if (!quad_list[i].arg1.empty()) {
                for (size_t j = 0; j < quad_list.size(); j++) {
                    if (quad_list[j].result == quad_list[i].arg1) used[j] = true;
                }
            }
            if (!quad_list[i].arg2.empty()) {
                for (size_t j = 0; j < quad_list.size(); j++) {
                    if (quad_list[j].result == quad_list[i].arg2) used[j] = true;
                }
            }
        }
        // Eliminate assignments whose result is never used
        for (size_t i = 0; i < quad_list.size(); i++) {
            if (quad_list[i].eliminated) continue;
            if (!quad_list[i].result.empty() && !used[i]) {
                quad_list[i].eliminated = true;
                changed = true;
                cout << "  Eliminated dead code at Quad " << i+1 << " (" << quad_list[i].op << " " << quad_list[i].arg1 << " " << quad_list[i].arg2 << " " << quad_list[i].result << ")" << endl;
            }
        }
        if (!changed) cout << "  No dead code found." << endl;
        cout << string(40, '-') << endl;
    }

    void copyPropagation() {
        cout << "\nPerforming Copy Propagation..." << endl;
        bool changed = false;
        for (size_t i = 0; i < quad_list.size(); i++) {
            if (quad_list[i].eliminated) continue;
            if (quad_list[i].op == "=" && !quad_list[i].arg1.empty() && quad_list[i].arg2.empty()) {
                string src = quad_list[i].arg1;
                string dest = quad_list[i].result;
                for (size_t j = i + 1; j < quad_list.size(); j++) {
                    if (quad_list[j].eliminated) continue;
                    if (quad_list[j].arg1 == dest) {
                        quad_list[j].arg1 = src;
                        changed = true;
                        cout << "  Propagated copy from Quad " << i+1 << " to Quad " << j+1 << " (arg1)" << endl;
                    }
                    if (quad_list[j].arg2 == dest) {
                        quad_list[j].arg2 = src;
                        changed = true;
                        cout << "  Propagated copy from Quad " << i+1 << " to Quad " << j+1 << " (arg2)" << endl;
                    }
                }
            }
        }
        if (!changed) cout << "  No copy propagation opportunities found." << endl;
        cout << string(40, '-') << endl;
    }
};

int main(int argc, char* argv[]) {
    string quad_filename = "music_score1quads";
    if (argc > 1) {
        quad_filename = argv[1];
    }

    cout << "--- Quadruple Optimizer (C++ Version) ---" << endl;

    QuadrupleOptimizer optimizer;
    if (!optimizer.readQuadsFromFile(quad_filename)) {
        cerr << "Failed to read quadruples from " << quad_filename << ". Exiting." << endl;
        return 1;
    }

    optimizer.printQuads("Initial Quads Loaded", false);

    int option = 0;
    while (option < 1 || option > 5) {
        cout << "\nSelect optimization technique:" << endl;
        cout << "  1. Common Subexpression Elimination (CSE)" << endl;
        cout << "  2. Constant Folding" << endl;
        cout << "  3. Constant Propagation (includes Folding)" << endl;
        cout << "  4. Dead Code Elimination" << endl;
        cout << "  5. Copy Propagation" << endl;
        cout << "Enter your choice (1-5): ";
        cin >> option;

        if (cin.fail() || option < 1 || option > 5) {
            cin.clear();
            cin.ignore(10000, '\n');
            cout << "Invalid choice. Please enter 1, 2, 3, 4, or 5." << endl;
            option = 0;
        }
    }

    switch(option) {
        case 1:
            optimizer.commonSubexpressionElimination();
            break;
        case 2:
            optimizer.constantFoldingOptimization();
            break;
        case 3:
            optimizer.constantPropagationOptimization();
            break;
        case 4:
            optimizer.deadCodeElimination();
            break;
        case 5:
            optimizer.copyPropagation();
            break;
    }

    optimizer.printQuads("Optimized Quadruples", false);
    return 0;
} 
//steps to run:
//scroll below of the next code for input or search for input optim
1]g++ name.cpp -o name
2]./name input

//optimization in java:
import java.io.*;
import java.util.*;

class Quadruple {
    String op;
    String arg1;
    String arg2;
    String result;
    boolean eliminated;
    boolean isLeader;

    public Quadruple() {
        eliminated = false;
        isLeader = false;
    }
}

public class Optimizer {
    private static final int MAX_QUADS = 500;
    private ArrayList<Quadruple> quadList;

    public Optimizer() {
        quadList = new ArrayList<>();
    }

    private boolean isConstant(String s) {
        if (s == null || s.isEmpty()) return false;
        int start = (s.charAt(0) == '+' || s.charAt(0) == '-') ? 1 : 0;
        if (start == s.length()) return false;
        for (int i = start; i < s.length(); i++) {
            if (!Character.isDigit(s.charAt(i))) return false;
        }
        return true;
    }

    private int evaluateExpression(String op, int c1, int c2) {
        switch (op) {
            case "+": return c1 + c2;
            case "-": return c1 - c2;
            case "*": return c1 * c2;
            case "/": return c2 != 0 ? c1 / c2 : 0;
            default: return 0;
        }
    }

    public boolean readQuadsFromFile(String filename) {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            System.out.println("Reading Quads from " + filename + "...");
            String line;
            while ((line = reader.readLine()) != null && quadList.size() < MAX_QUADS) {
                if (line.trim().isEmpty()) continue;

                String[] parts = line.trim().split("\\s+");
                if (parts.length >= 1) {
                    Quadruple quad = new Quadruple();
                    quad.op = parts[0];
                    quad.arg1 = parts.length > 1 && !parts[1].equals("-") ? parts[1] : "";
                    quad.arg2 = parts.length > 2 && !parts[2].equals("-") ? parts[2] : "";
                    quad.result = parts.length > 3 && !parts[3].equals("-") ? parts[3] : "";
                    quadList.add(quad);
                }
            }
            System.out.println("Read " + quadList.size() + " quads.");
            return true;
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
            return false;
        }
    }

    public void printQuads(String title, boolean showEliminated) {
        System.out.println("\n--- " + title + " ---");
        System.out.printf("%-3s| %-15s | %-25s | %-25s | %-25s | %s%n",
                "Nr", "Op", "Arg1", "Arg2", "Result", showEliminated ? "Status" : "");
        System.out.println("-".repeat(95));

        if (quadList.isEmpty()) {
            System.out.println("(No Quads)");
            return;
        }

        int displayedCount = 0;
        for (int i = 0; i < quadList.size(); i++) {
            Quadruple quad = quadList.get(i);
            if (!quad.eliminated || showEliminated) {
                displayedCount++;
                System.out.printf("%03d| %-15s | %-25s | %-25s | %-25s | %s%n",
                        i + 1, quad.op, quad.arg1, quad.arg2, quad.result,
                        showEliminated ? (quad.eliminated ? "(Elim)" : "") : "");
            }
        }

        if (displayedCount == 0 && !showEliminated) {
            System.out.println("(No quads remaining after optimization)");
        }
        System.out.println("-".repeat(95));
    }

    public void commonSubexpressionElimination() {
        System.out.println("\nPerforming Common Subexpression Elimination...");
        boolean eliminatedFound = false;

        for (int i = 0; i < quadList.size(); i++) {
            if (quadList.get(i).eliminated) continue;
            if (quadList.get(i).op.equals("=")) continue;

            for (int j = 0; j < i; j++) {
                if (quadList.get(j).eliminated) continue;
                if (quadList.get(j).op.equals("=")) continue;

                Quadruple qi = quadList.get(i);
                Quadruple qj = quadList.get(j);

                if (qi.op.equals(qj.op) &&
                    qi.arg1.equals(qj.arg1) &&
                    qi.arg2.equals(qj.arg2))
                {
                    System.out.printf("  Found potential CSE: Quad %d (%s %s %s %s) same as Quad %d (%s %s %s %s)%n",
                            i + 1, qi.op, qi.arg1, qi.arg2, qi.result,
                            j + 1, qj.op, qj.arg1, qj.arg2, qj.result);
                    System.out.printf("    Eliminating Quad %d. Uses of '%s' should be replaced by '%s'%n",
                            i + 1, qi.result, qj.result);

                    qi.eliminated = true;
                    eliminatedFound = true;
                    break;
                }
            }
        }
        if (!eliminatedFound) System.out.println("  No common subexpressions identified for elimination.");
        System.out.println("-".repeat(40));
    }

    public void constantFoldingOptimization() {
        System.out.println("\nPerforming Constant Folding...");
        boolean changed = false;

        for (int i = 0; i < quadList.size(); i++) {
            Quadruple quad = quadList.get(i);
            if ((quad.op.equals("+") || quad.op.equals("-") ||
                 quad.op.equals("*") || quad.op.equals("/")) &&
                isConstant(quad.arg1) && isConstant(quad.arg2))
            {
                String origOp = quad.op;
                String origArg1 = quad.arg1;
                String origArg2 = quad.arg2;

                int c1 = Integer.parseInt(quad.arg1);
                int c2 = Integer.parseInt(quad.arg2);

                if (quad.op.equals("/") && c2 == 0) continue;

                int resultVal = evaluateExpression(quad.op, c1, c2);
                
                System.out.printf("  Folding Quad %d (%s = %s %s %s) -> (%s = %d)%n",
                        i + 1, quad.result, origArg1, origOp, origArg2, quad.result, resultVal);

                quad.op = "=";
                quad.arg1 = String.valueOf(resultVal);
                quad.arg2 = "";
                changed = true;
            }
        }
        if (!changed) System.out.println("  No constant folding opportunities found.");
        System.out.println("-".repeat(40));
    }

    public void constantPropagationOptimization() {
        System.out.println("\nPerforming Constant Propagation (and Folding)...");
        boolean changedProp = false;
        boolean changedFold = false;

        // Constant Propagation
        for (int i = 0; i < quadList.size(); i++) {
            Quadruple quad = quadList.get(i);
            if (quad.op.equals("=") && isConstant(quad.arg1) && quad.arg2.isEmpty()) {
                String varToProp = quad.result;
                String constVal = quad.arg1;

                for (int j = i + 1; j < quadList.size(); j++) {
                    Quadruple qj = quadList.get(j);
                    boolean propagatedHere = false;

                    if (qj.op.equals("+") || qj.op.equals("-") ||
                        qj.op.equals("*") || qj.op.equals("/"))
                    {
                        if (qj.arg1.equals(varToProp)) {
                            qj.arg1 = constVal;
                            propagatedHere = true;
                        }
                        if (qj.arg2.equals(varToProp)) {
                            qj.arg2 = constVal;
                            propagatedHere = true;
                        }
                    }

                    if (propagatedHere) {
                        System.out.printf("  Propagated '%s = %s' from Quad %d into Quad %d%n",
                                varToProp, constVal, i + 1, j + 1);
                        changedProp = true;
                    }
                }
            }
        }
        if (!changedProp) System.out.println("  No constant propagation opportunities found.");

        // Follow-up Constant Folding
        System.out.println("  Running follow-up Constant Folding...");
        for (int i = 0; i < quadList.size(); i++) {
            Quadruple quad = quadList.get(i);
            if ((quad.op.equals("+") || quad.op.equals("-") ||
                 quad.op.equals("*") || quad.op.equals("/")) &&
                isConstant(quad.arg1) && isConstant(quad.arg2))
            {
                String origOp = quad.op;
                String origArg1 = quad.arg1;
                String origArg2 = quad.arg2;

                int c1 = Integer.parseInt(quad.arg1);
                int c2 = Integer.parseInt(quad.arg2);

                if (quad.op.equals("/") && c2 == 0) continue;

                int resultVal = evaluateExpression(quad.op, c1, c2);
                
                System.out.printf("    Folding Quad %d (%s = %s %s %s) -> (%s = %d)%n",
                        i + 1, quad.result, origArg1, origOp, origArg2, quad.result, resultVal);

                quad.op = "=";
                quad.arg1 = String.valueOf(resultVal);
                quad.arg2 = "";
                changedFold = true;
            }
        }
        if (!changedFold) System.out.println("    No further folding opportunities found.");
        System.out.println("-".repeat(40));
    }

    public void deadCodeElimination() {
        System.out.println("\nPerforming Dead Code Elimination...");
        boolean changed = false;
        boolean[] used = new boolean[quadList.size()];
        // Mark variables that are used as arguments in non-eliminated quads
        for (int i = 0; i < quadList.size(); i++) {
            Quadruple q = quadList.get(i);
            if (q.eliminated) continue;
            if (!q.arg1.isEmpty()) {
                for (int j = 0; j < quadList.size(); j++) {
                    if (quadList.get(j).result.equals(q.arg1)) used[j] = true;
                }
            }
            if (!q.arg2.isEmpty()) {
                for (int j = 0; j < quadList.size(); j++) {
                    if (quadList.get(j).result.equals(q.arg2)) used[j] = true;
                }
            }
        }
        // Eliminate assignments whose result is never used
        for (int i = 0; i < quadList.size(); i++) {
            Quadruple q = quadList.get(i);
            if (q.eliminated) continue;
            if (!q.result.isEmpty() && !used[i]) {
                q.eliminated = true;
                changed = true;
                System.out.printf("  Eliminated dead code at Quad %d (%s %s %s %s)\n", i+1, q.op, q.arg1, q.arg2, q.result);
            }
        }
        if (!changed) System.out.println("  No dead code found.");
        System.out.println("-".repeat(40));
    }

    public void copyPropagation() {
        System.out.println("\nPerforming Copy Propagation...");
        boolean changed = false;
        for (int i = 0; i < quadList.size(); i++) {
            Quadruple qi = quadList.get(i);
            if (qi.eliminated) continue;
            if (qi.op.equals("=") && !qi.arg1.isEmpty() && qi.arg2.isEmpty()) {
                String src = qi.arg1;
                String dest = qi.result;
                for (int j = i + 1; j < quadList.size(); j++) {
                    Quadruple qj = quadList.get(j);
                    if (qj.eliminated) continue;
                    if (qj.arg1.equals(dest)) {
                        qj.arg1 = src;
                        changed = true;
                        System.out.printf("  Propagated copy from Quad %d to Quad %d (arg1)\n", i+1, j+1);
                    }
                    if (qj.arg2.equals(dest)) {
                        qj.arg2 = src;
                        changed = true;
                        System.out.printf("  Propagated copy from Quad %d to Quad %d (arg2)\n", i+1, j+1);
                    }
                }
            }
        }
        if (!changed) System.out.println("  No copy propagation opportunities found.");
        System.out.println("-".repeat(40));
    }

    public static void main(String[] args) {
        String quadFilename = "music_score1quads";
        if (args.length > 0) {
            quadFilename = args[0];
        }

        System.out.println("--- Quadruple Optimizer (Java Version) ---");

        Optimizer optimizer = new Optimizer();
        if (!optimizer.readQuadsFromFile(quadFilename)) {
            System.err.println("Failed to read quadruples from " + quadFilename + ". Exiting.");
            System.exit(1);
        }

        optimizer.printQuads("Initial Quads Loaded", false);

        Scanner scanner = new Scanner(System.in);
        int option = 0;
        while (option < 1 || option > 5) {
            System.out.println("\nSelect optimization technique:");
            System.out.println("  1. Common Subexpression Elimination (CSE)");
            System.out.println("  2. Constant Folding");
            System.out.println("  3. Constant Propagation (includes Folding)");
            System.out.println("  4. Dead Code Elimination");
            System.out.println("  5. Copy Propagation");
            System.out.print("Enter your choice (1-5): ");
            try {
                option = scanner.nextInt();
                if (option < 1 || option > 5) {
                    System.out.println("Invalid choice. Please enter 1, 2, 3, 4, or 5.");
                    option = 0;
                }
            } catch (InputMismatchException e) {
                System.out.println("Invalid input. Please enter a number between 1 and 5.");
                scanner.nextLine();
                option = 0;
            }
        }

        switch(option) {
            case 1:
                optimizer.commonSubexpressionElimination();
                break;
            case 2:
                optimizer.constantFoldingOptimization();
                break;
            case 3:
                optimizer.constantPropagationOptimization();
                break;
            case 4:
                optimizer.deadCodeElimination();
                break;
            case 5:
                optimizer.copyPropagation();
                break;
        }

        optimizer.printQuads("Optimized Quadruples", false);
    }
} 
//steps to run
1]javac name.java
2]java name input
// input optim
= 5 x
= 10 y
+ x y t1
* x y t2
+ x y t3
= 5 z
+ z y t4  
* x y t5
+ 2 3 t6
* 4 5 t7
+ 2 3 t8
= 10 w
+ w z t9
* w z t10

//handwritten lexer using C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Token types
typedef enum {
    TOKEN_IDENTIFIER,
    TOKEN_NUMBER,
    TOKEN_OPERATOR,
    TOKEN_KEYWORD,
    TOKEN_STRING,
    TOKEN_SYMBOL,
    TOKEN_EOF,
    TOKEN_ERROR
} TokenType;

// Token structure
typedef struct {
    TokenType type;
    char* value;
    int line;
    int column;
} Token;

// Keywords
const char* keywords[] = {
    "if", "else", "while", "for", "int", "float", "char", "return", "void", "main"
};

// Maximum token length
#define MAX_TOKEN_LENGTH 100
#define MAX_FILE_SIZE 1024

// Current position in input
char* current;
int line = 1;
int column = 1;

// Function to check if a string is a keyword
int isKeyword(const char* str) {
    int numKeywords = sizeof(keywords) / sizeof(keywords[0]);
    for (int i = 0; i < numKeywords; i++) {
        if (strcmp(str, keywords[i]) == 0) {
            return 1;
        }
    }
    return 0;
}

// Function to create a new token
Token* createToken(TokenType type, const char* value) {
    Token* token = (Token*)malloc(sizeof(Token));
    token->type = type;
    token->value = strdup(value);
    token->line = line;
    token->column = column - strlen(value);
    return token;
}

// Function to get the next token
Token* getNextToken() {
    // Skip whitespace
    while (isspace(*current)) {
        if (*current == '\n') {
            line++;
            column = 1;
        } else {
            column++;
        }
        current++;
    }

    // Check for end of input
    if (*current == '\0') {
        return createToken(TOKEN_EOF, "EOF");
    }

    // Handle identifiers and keywords
    if (isalpha(*current) || *current == '_') {
        char buffer[MAX_TOKEN_LENGTH];
        int i = 0;
        while (isalnum(*current) || *current == '_') {
            buffer[i++] = *current++;
            column++;
        }
        buffer[i] = '\0';

        if (isKeyword(buffer)) {
            return createToken(TOKEN_KEYWORD, buffer);
        } else {
            return createToken(TOKEN_IDENTIFIER, buffer);
        }
    }

    // Handle numbers
    if (isdigit(*current)) {
        char buffer[MAX_TOKEN_LENGTH];
        int i = 0;
        while (isdigit(*current) || *current == '.') {
            buffer[i++] = *current++;
            column++;
        }
        buffer[i] = '\0';
        return createToken(TOKEN_NUMBER, buffer);
    }

    // Handle strings
    if (*current == '"') {
        char buffer[MAX_TOKEN_LENGTH];
        int i = 0;
        current++;
        column++;
        while (*current != '"' && *current != '\0') {
            buffer[i++] = *current++;
            column++;
        }
        if (*current == '"') {
            current++;
            column++;
        } else {
            return createToken(TOKEN_ERROR, "Unterminated string");
        }
        buffer[i] = '\0';
        return createToken(TOKEN_STRING, buffer);
    }

    // Handle operators and symbols
    if (strchr("+-*/=<>!&|", *current)) {
        char buffer[3] = {0};
        buffer[0] = *current++;
        column++;
        
        // Check for two-character operators
        if (strchr("=<>|&", *current)) {
            buffer[1] = *current++;
            column++;
        }
        
        return createToken(TOKEN_OPERATOR, buffer);
    }

    // Handle single-character symbols
    if (strchr("(){}[];,:", *current)) {
        char buffer[2] = {*current++, '\0'};
        column++;
        return createToken(TOKEN_SYMBOL, buffer);
    }

    // Unknown character
    char buffer[2] = {*current++, '\0'};
    column++;
    return createToken(TOKEN_ERROR, buffer);
}

// Function to print token information
void printToken(Token* token) {
    const char* typeNames[] = {
        "IDENTIFIER", "NUMBER", "OPERATOR", "KEYWORD",
        "STRING", "SYMBOL", "EOF", "ERROR"
    };
    
    printf("Token: %-12s Value: %-10s Line: %d, Column: %d\n",
           typeNames[token->type], token->value, token->line, token->column);
}

// Function to free token memory
void freeToken(Token* token) {
    free(token->value);
    free(token);
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input_file>\n", argv[0]);
        return 1;
    }

    FILE* file = fopen(argv[1], "r");
    if (!file) {
        printf("Error: Could not open file %s\n", argv[1]);
        return 1;
    }

    // Read the entire file
    char* input = (char*)malloc(MAX_FILE_SIZE);
    if (!input) {
        printf("Error: Memory allocation failed\n");
        fclose(file);
        return 1;
    }

    size_t fileSize = fread(input, 1, MAX_FILE_SIZE - 1, file);
    input[fileSize] = '\0';
    fclose(file);

    current = input;
    
    printf("Lexical Analysis Results:\n");
    printf("------------------------\n");
    
    Token* token;
    do {
        token = getNextToken();
        printToken(token);
        freeToken(token);
    } while (token->type != TOKEN_EOF && token->type != TOKEN_ERROR);
    
    free(input);
    return 0;
} 
//input 
int main() {
    int x = 10;
    if (x > 5) {
        printf("Hello, world!");
    }
    return 0;
} 
//note to run :name the code lexer.c 1] gcc lexer.c -o lexer 2] .\lexer test_input.txt

//handwritten lexer using java
import java.util.Arrays;
import java.util.List;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Lexer {
    // Token types
    public enum TokenType {
        IDENTIFIER,
        NUMBER,
        OPERATOR,
        KEYWORD,
        STRING,
        SYMBOL,
        EOF,
        ERROR
    }

    // Token class
    public static class Token {
        public final TokenType type;
        public final String value;
        public final int line;
        public final int column;

        public Token(TokenType type, String value, int line, int column) {
            this.type = type;
            this.value = value;
            this.line = line;
            this.column = column;
        }

        @Override
        public String toString() {
            return String.format("Token: %-12s Value: %-10s Line: %d, Column: %d",
                    type, value, line, column);
        }
    }

    // Keywords
    private static final List<String> KEYWORDS = Arrays.asList(
            "if", "else", "while", "for", "int", "float", "char", "return", "void", "main"
    );

    // Input text and position tracking
    private final String input;
    private int position;
    private int line;
    private int column;

    public Lexer(String input) {
        this.input = input;
        this.position = 0;
        this.line = 1;
        this.column = 1;
    }

    // Check if a string is a keyword
    private boolean isKeyword(String str) {
        return KEYWORDS.contains(str);
    }

    // Get the next token
    public Token getNextToken() {
        // Skip whitespace
        while (position < input.length() && Character.isWhitespace(input.charAt(position))) {
            if (input.charAt(position) == '\n') {
                line++;
                column = 1;
            } else {
                column++;
            }
            position++;
        }

        // Check for end of input
        if (position >= input.length()) {
            return new Token(TokenType.EOF, "EOF", line, column);
        }

        char current = input.charAt(position);

        // Handle identifiers and keywords
        if (Character.isLetter(current) || current == '_') {
            StringBuilder buffer = new StringBuilder();
            while (position < input.length() && 
                   (Character.isLetterOrDigit(input.charAt(position)) || 
                    input.charAt(position) == '_')) {
                buffer.append(input.charAt(position));
                position++;
                column++;
            }

            String value = buffer.toString();
            return new Token(
                isKeyword(value) ? TokenType.KEYWORD : TokenType.IDENTIFIER,
                value,
                line,
                column - value.length()
            );
        }

        // Handle numbers
        if (Character.isDigit(current)) {
            StringBuilder buffer = new StringBuilder();
            while (position < input.length() && 
                   (Character.isDigit(input.charAt(position)) || 
                    input.charAt(position) == '.')) {
                buffer.append(input.charAt(position));
                position++;
                column++;
            }
            return new Token(TokenType.NUMBER, buffer.toString(), line, column - buffer.length());
        }

        // Handle strings
        if (current == '"') {
            StringBuilder buffer = new StringBuilder();
            position++;
            column++;
            while (position < input.length() && input.charAt(position) != '"') {
                buffer.append(input.charAt(position));
                position++;
                column++;
            }
            if (position < input.length() && input.charAt(position) == '"') {
                position++;
                column++;
                return new Token(TokenType.STRING, buffer.toString(), line, column - buffer.length() - 2);
            } else {
                return new Token(TokenType.ERROR, "Unterminated string", line, column);
            }
        }

        // Handle operators and symbols
        if ("+-*/=<>!&|".indexOf(current) != -1) {
            StringBuilder buffer = new StringBuilder();
            buffer.append(current);
            position++;
            column++;
            
            // Check for two-character operators
            if (position < input.length() && "=<>|&".indexOf(input.charAt(position)) != -1) {
                buffer.append(input.charAt(position));
                position++;
                column++;
            }
            
            return new Token(TokenType.OPERATOR, buffer.toString(), line, column - buffer.length());
        }

        // Handle single-character symbols
        if ("(){}[];,:. ".indexOf(current) != -1) {
            String value = String.valueOf(current);
            position++;
            column++;
            return new Token(TokenType.SYMBOL, value, line, column - 1);
        }

        // Unknown character
        String value = String.valueOf(current);
        position++;
        column++;
        return new Token(TokenType.ERROR, value, line, column - 1);
    }

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println("Usage: java Lexer <input_file>");
            System.exit(1);
        }

        try {
            // Read the entire file
            StringBuilder inputBuilder = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(new FileReader(args[0]))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    inputBuilder.append(line).append("\n");
                }
            }

            String input = inputBuilder.toString();
            Lexer lexer = new Lexer(input);
            System.out.println("Lexical Analysis Results:");
            System.out.println("------------------------");

            Token token;
            do {
                token = lexer.getNextToken();
                System.out.println(token);
            } while (token.type != TokenType.EOF && token.type != TokenType.ERROR);
        } catch (IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
            System.exit(1);
        }
    }
} 
//Note to run :name the code Lexer 1]javac Lexer.java then 2] java Lexer test_input.txt
//clexxer (C lexer)
//code:
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int lno = 1;
int col = 1;

extern FILE *yyin;
extern int yylex();
extern char *yytext;
extern int yyleng;

%}

%%

[ \t]+          { col += yyleng; }
\n              { lno++; col = 1; }

"int"|"return"|"if"|"else"|"for"|"float"|"define"|"include" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "KEYWORD", yytext);
    col += yyleng;
}

\"[^\"\n]*\"    {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "STRING", yytext);
    col += yyleng;
}

[a-zA-Z_][a-zA-Z0-9_]* {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "IDENTIFIER", yytext);
    col += yyleng;
}

[0-9]+\.[0-9]+  {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "FLOAT", yytext);
    col += yyleng;
}

[0-9]+          {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "NUMBER", yytext);
    col += yyleng;
}

"="|">"|"*"|"/" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "OPERATOR", yytext);
    col += yyleng;
}

"{"|"}"|"("|")"|";"|"#"|","|"."|"<"|">" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "SYMBOL", yytext);
    col += yyleng;
}

.               {
    int current_col = col;
    fprintf(stderr, "\nLexical Error: Undefinded token '%s' at Line %d, Column %d. Terminating.\n", yytext, lno, current_col);
    exit(EXIT_FAILURE);
}

%%

int yywrap() {
    return 1;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <input_filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    yyin = fopen(argv[1], "r");

    if (yyin == NULL) {
        perror(argv[1]);
        exit(EXIT_FAILURE);
    }

    printf("| %-6s | %-6s | %-15s | %-10s | %-12s |\n", "Column", "Line", "Lexeme", "Token", "Token Value");
    printf("|--------|--------|-----------------|------------|--------------|\n");

    yylex();

    printf("|--------|--------|-----------------|------------|--------------|\n");

    fclose(yyin);

    return 0;
}

//steps to run:
// flex clexxer.l
// gcc lex.yy.c -o c
// ./c input.c
//input:
#include <stdio.h>

#define MAX 100

int main() {
    int num1 = 10, num2 = 20;
    float result;

    if (num1 > num2) {
        result = num1 * 1;
    } else {
        result = num2 / 2
    }
    
    printf("Result: %.2f\n", result);
    return 0;
}

//javalex (Java lexer)
//code:
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int lno = 1;
int col = 1;

extern FILE *yyin;
extern int yylex();
extern char *yytext;
extern int yyleng;

%}

%option noyywrap

%%

[ \t\f]+        { col += yyleng; }
"//"[^\n]* { col += yyleng; }

(\n|\r|\r\n)    { lno++; col = 1; }


"abstract"|"assert"|"boolean"|"break"|"byte"|"case"|"catch"|"char"|"class"|"const"|"continue"|"default"|"do"|"double"|"else"|"enum"|"extends"|"final"|"finally"|"float"|"for"|"goto"|"if"|"implements"|"import"|"instanceof"|"int"|"interface"|"long"|"native"|"new"|"package"|"private"|"protected"|"public"|"return"|"short"|"static"|"strictfp"|"super"|"switch"|"synchronized"|"this"|"throw"|"throws"|"transient"|"try"|"void"|"volatile"|"while"|"true"|"false"|"null" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "KEYWORD", yytext);
    col += yyleng;
}


[0-9]+\.[0-9]+  { /* Using unescaped dot again */
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "FLOAT_LIT", yytext);
    col += yyleng;
}
[0-9]+          {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "INTEGER_LIT", yytext);
    col += yyleng;
}


\"([^\\"\n]|\\[^\n])*\" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "STRING_LIT", yytext);
    col += yyleng;
}


[a-zA-Z_$][a-zA-Z0-9_$]* {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "IDENTIFIER", yytext);
    col += yyleng;
}


"++"|"--"|"=="|"!="|"<="|">="|"&&"|"||"|"+"|"-"|"*"|"/"|"%"|"&"|"|"|"^"|"!"|"~"|"<"|">"|"=" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "OPERATOR", yytext);
    col += yyleng;
}


[()\{\}\[\];,\.] {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "SEPARATOR", yytext);
    col += yyleng;
}


.               {
    int current_col = col;
    fprintf(stderr, "\nLexical Error: Unrecognized character '%s' at Line %d, Column %d. Terminating.\n", yytext, lno, current_col);
    exit(EXIT_FAILURE);
}


%%

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <input_filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    yyin = fopen(argv[1], "r");

    if (yyin == NULL) {
        perror(argv[1]);
        exit(EXIT_FAILURE);
    }

    printf("| %-6s | %-6s | %-15s | %-10s | %-12s |\n", "Column", "Line", "Lexeme", "Token", "Token Value");
    printf("|--------|--------|-----------------|------------|--------------|\n");

    yylex();

    printf("|--------|--------|-----------------|------------|--------------|\n");

    fclose(yyin);

    return 0;
}

//steps to run:
// flex javalex.l
// gcc lex.yy.c -o javalex
// ./javalex input.java
//input:
public class input {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

//pylexxer (Python lexer)
//code:
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int lno = 1;
int col = 1;

extern FILE *yyin;
extern int yylex();
extern char *yytext;
extern int yyleng;

%}

%%

[ \t]+          { col += yyleng; }
\#[^\n]* { col += yyleng; }
\n              { lno++; col = 1; }


"def"|"if"|"else"|"return"|"class"|"for"|"while"|"in"|"is"|"not"|"and"|"or"|"True"|"False"|"None"|"import"|"from"|"try"|"except"|"finally"|"with"|"as"|"yield"|"lambda"|"pass"|"break"|"continue"|"global"|"nonlocal"|"assert"|"del"|"elif" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "KEYWORD", yytext);
    col += yyleng;
}



[fFrRbB]?"""[^\n]*""" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "TRPL_STRING", yytext);
    col += yyleng;
}
[fFrRbB]?\'\'\'[^\n]*\'\'\' {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "TRPL_STRING", yytext);
    col += yyleng;
}
[fFrRbB]\'[^\'\n]*\' {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "PREFIX_STRING", yytext);
    col += yyleng;
}
[fFrRbB]\"[^\"\n]*\" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "PREFIX_STRING", yytext);
    col += yyleng;
}
\'[^\'\n]*\' {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "STRING", yytext);
    col += yyleng;
}
\"[^\"\n]*\" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "STRING", yytext);
    col += yyleng;
}


[a-zA-Z_][a-zA-Z0-9_]* {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "IDENTIFIER", yytext);
    col += yyleng;
}


[0-9]+\.[0-9]+  {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "FLOAT", yytext);
    col += yyleng;
}
[0-9]+          {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "NUMBER", yytext);
    col += yyleng;
}


"=="|"!="|"<="|">="|"**"|"//"|"+"|"-"|"*"|"/"|"<"|">"|"=" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "OPERATOR", yytext);
    col += yyleng;
}


"("|")"|"["|"]"|"{"|"}"|":"|","|"." {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "SYMBOL", yytext);
    col += yyleng;
}


.               {
    int current_col = col;
    fprintf(stderr, "\nLexical Error: Undefinded token '%s' at Line %d, Column %d. Terminating.\n", yytext, lno, current_col);
    exit(EXIT_FAILURE);
}

%%

int yywrap() {
    return 1;
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <input_filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    yyin = fopen(argv[1], "r");

    if (yyin == NULL) {
        perror(argv[1]);
        exit(EXIT_FAILURE);
    }

    printf("| %-6s | %-6s | %-15s | %-10s | %-12s |\n", "Column", "Line", "Lexeme", "Token", "Token Value");
    printf("|--------|--------|-----------------|------------|--------------|\n");

    yylex();

    printf("|--------|--------|-----------------|------------|--------------|\n");

    fclose(yyin);

    return 0;
}

//steps to run:
// flex pylexxer.l
// gcc lex.yy.c -o pylexxer
// ./pylexxer input.py
//input:
def calculate_average(numbers):
    """This function calculates the average"""
    total = sum(numbers)
    count = len(numbers)
    
    if count == 0:
        return 0  # Avoid division by zero
    else:
        return total / count

data = [10, 20, 30, 40, 50]
average = calculate_average(data)

print(f"The average is: {average:.2f}")

//sqllexxer (SQL lexer)
//code:
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int lno = 1;
int col = 1;

extern FILE *yyin;
extern int yylex();
extern char *yytext;
extern int yyleng;

%}

%option noyywrap case-insensitive
%x ML_COMMENT

%%

<INITIAL>[ \t\r\f]+     { col += yyleng; }
<INITIAL>"--"[^\n]* { col += yyleng; }
<INITIAL>"/*"           { BEGIN(ML_COMMENT); col += yyleng; }
<INITIAL>\n             { lno++; col = 1; }


<INITIAL>"SELECT"|"FROM"|"WHERE"|"INSERT"|"INTO"|"VALUES"|"UPDATE"|"SET"|"DELETE"|"CREATE"|"TABLE"|"DATABASE"|"ALTER"|"DROP"|"INDEX"|"VIEW"|"AND"|"OR"|"NOT"|"NULL"|"TRUE"|"FALSE"|"AS"|"ORDER"|"BY"|"GROUP"|"HAVING"|"ASC"|"DESC"|"JOIN"|"LEFT"|"RIGHT"|"INNER"|"OUTER"|"ON"|"DISTINCT"|"LIMIT"|"OFFSET"|"VARCHAR"|"INT"|"INTEGER"|"FLOAT"|"DOUBLE"|"DECIMAL"|"DATE"|"DATETIME"|"TIMESTAMP"|"TEXT"|"BLOB"|"PRIMARY"|"KEY"|"FOREIGN"|"REFERENCES"|"UNIQUE"|"CHECK"|"DEFAULT"|"CONSTRAINT"|"IS"|"LIKE"|"IN" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "KEYWORD", yytext);
    col += yyleng;
}


<INITIAL>\'([^']|\'\')*\' {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "STRING_LIT", yytext);
    col += yyleng;
}
<INITIAL>[[:digit:]]+[.]+[[:digit:]]+ {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "FLOAT_LIT", yytext);
    col += yyleng;
}
<INITIAL>[[:digit:]]+ {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "INTEGER_LIT", yytext);
    col += yyleng;
}


<INITIAL>\"[^"]*\" {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "QUOTED_ID", yytext);
    col += yyleng;
}
<INITIAL>[a-zA-Z_][a-zA-Z0-9_]* {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "IDENTIFIER", yytext);
    col += yyleng;
}


<INITIAL>[=><+\-*\/%%] {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "OPERATOR", yytext);
    col += yyleng;
}


<INITIAL>[(),;\.] {
    int current_col = col;
    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", current_col, lno, yytext, "SYMBOL", yytext);
    col += yyleng;
}


<INITIAL>. {
    int current_col = col;
    fprintf(stderr, "\nLexical Error: Unrecognized character '%s' at Line %d, Column %d. Terminating.\n", yytext, lno, current_col);
    exit(EXIT_FAILURE);
}


<ML_COMMENT>"*/"        { BEGIN(INITIAL); col += yyleng; }
<ML_COMMENT>[^*\n]+     { col += yyleng; }
<ML_COMMENT>"*"         { col += yyleng; }
<ML_COMMENT>\n          { lno++; col = 1; }


%%



int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <input_filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    yyin = fopen(argv[1], "r");

    if (yyin == NULL) {
        perror(argv[1]);
        exit(EXIT_FAILURE);
    }

    printf("| %-6s | %-6s | %-15s | %-10s | %-12s |\n", "Column", "Line", "Lexeme", "Token", "Token Value");
    printf("|--------|--------|-----------------|------------|--------------|\n");

    yylex();

    printf("|--------|--------|-----------------|------------|--------------|\n");

    fclose(yyin);

    return 0;
}

//steps to run:
// flex sqllexxer.l
// gcc lex.yy.c -o sqllexxer
// ./sqllexxer input.sql
//input:
SELECT name, age FROM users WHERE age > 21;

INSERT INTO customers VALUES ('John Doe', 35, 'john@example.com');
UPDATE products 
SET price = price * 0.9 
WHERE category = 'electronics';

DELETE FROM orders WHERE order_date < '2023-01-01';

CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(100), department VARCHAR(50));
SELECT o.order_id, c.name, p.product_name
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
WHERE o.status = 'completed' AND p.category = 'books';

//englex (English lexer)
//code:
%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#define MODE_ENGLISH 4

int line_num = 1;
int column_num = 1;

const char *englishStopwords[] = {
    "a", "an", "and", "are", "as", "at", "be", "but", "by", "for", "if", "in",
    "into", "is", "it", "no", "not", "of", "on", "or", "such", "that", "the",
    "their", "then", "there", "these", "they", "this", "to", "was", "will", "with", NULL
};

int isInList(const char *word, const char **list) {
    for (int i = 0; list[i] != NULL; i++) {
        if (strcasecmp(word, list[i]) == 0) return 1;
    }
    return 0;
}

const char* getTokenType(const char *value) {
    if (isInList(value, englishStopwords)) return "STOPWORD";
    if (isdigit(value[0])) return "NUMBER";
    if (value[0] == '\'' || value[0] == '"') return "STRING";
    if (ispunct(value[0])) return "PUNCTUATION";
    if (isalpha(value[0])) return "WORD";
    return "UNKNOWN";
}
%}

%option noyywrap

DIGIT       [0-9]
LETTER      [a-zA-Z]
WORD        {LETTER}+
NUMBER      {DIGIT}+(\.{DIGIT}+)?
PUNCT       [.,!?;:\"'()-]
WHITESPACE  [ \t]+
NEWLINE     \n
%%

{WHITESPACE} { column_num += yyleng; }

{NEWLINE}    { line_num++; column_num = 1; }

{WORD}       {
    const char *type = getTokenType(yytext);
    printf("| %-6d | %-6d | %-15s | %-12s | %-12s |\n",
           column_num, line_num, yytext, type, yytext);
    column_num += yyleng;
}

{NUMBER}     {
    printf("| %-6d | %-6d | %-15s | %-12s | %-12s |\n",
           column_num, line_num, yytext, "NUMBER", yytext);
    column_num += yyleng;
}

{PUNCT}      {
    printf("| %-6d | %-6d | %-15s | %-12s | %-12s |\n",
           column_num, line_num, yytext, "PUNCTUATION", yytext);
    column_num += yyleng;
}

.            {
    printf("| %-6d | %-6d | %-15s | %-12s | %-12s |\n",
           column_num, line_num, yytext, "UNKNOWN", yytext);
    column_num += yyleng;
    exit(EXIT_FAILURE);
}

%%

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    printf("| %-6s | %-6s | %-15s | %-12s | %-12s |\n",
           "Column", "Line", "Lexeme", "Token", "Token Value");
    printf("|--------|--------|-----------------|--------------|--------------|\n");

    yyin = fopen(argv[1], "r");
    if (!yyin) {
        fprintf(stderr, "Error opening file: %s\n", argv[1]);
        return 1;
    }

    yylex();
    fclose(yyin);
    return 0;
}

//steps to run:
// flex englex.l
// gcc lex.yy.c -o englex
// ./englex input.txt
//input:
The quick brown fox jumps over the lazy dog. This simple sentence contains
all parts of speech we want to analyze. Beautiful flowers bloom wonderfully
in spring, while cold winds blow fiercely in winter.

She loves reading interesting books quietly in her cozy room. They happily
played with their new toys yesterday. Our teacher explained the difficult
concept very clearly. 

//lexical analyser for c,python,sql(combined)
%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

// Language modes
#define MODE_SQL 0
#define MODE_C 1
#define MODE_PYTHON 2
#define MODE_ENGLISH 3

int current_mode = MODE_SQL;
int line_num = 1;
int column_num = 1;
int error_count = 0;

// For English analysis
int noun_count = 0;
int pronoun_count = 0;
int adjective_count = 0;
int verb_count = 0;
int adverb_count = 0;

// Keyword lists
const char *sqlKeywords[] = {
    "SELECT", "FROM", "WHERE", "INSERT", "UPDATE", "DELETE",
    "CREATE", "DROP", "TABLE", "VALUES", "INTO", "SET", NULL
};

const char *cKeywords[] = {
    "auto", "break", "case", "char", "const", "continue",
    "default", "do", "double", "else", "enum", "extern",
    "float", "for", "goto", "if", "int", "long",
    "register", "return", "short", "signed", "sizeof", "static",
    "struct", "switch", "typedef", "union", "unsigned", "void",
    "volatile", "while", NULL
};

const char *pythonKeywords[] = {
    "False", "None", "True", "and", "as", "assert",
    "async", "await", "break", "class", "continue", "def",
    "del", "elif", "else", "except", "finally", "for",
    "from", "global", "if", "import", "in", "is",
    "lambda", "nonlocal", "not", "or", "pass", "raise",
    "return", "try", "while", "with", "yield", NULL
};

const char *englishPronouns[] = {
    "I", "you", "he", "she", "it", "we", "they",
    "me", "him", "her", "us", "them",
    "my", "your", "his", "its", "our", "their",
    "mine", "yours", "hers", "ours", "theirs",
    "myself", "yourself", "himself", "herself",
    "itself", "ourselves", "yourselves", "themselves", NULL
};

const char *englishAdjectives[] = {
    "good", "bad", "big", "small", "happy", "sad",
    "beautiful", "ugly", "fast", "slow", "young", "old",
    "new", "old", "right", "wrong", "strong", "weak",
    "true", "false", "clever", "stupid", "rich", "poor",
    "hot", "cold", "warm", "cool", "soft", "hard", NULL
};

const char *englishAdverbs[] = {
    "quickly", "slowly", "well", "badly", "easily", "hard",
    "fast", "slow", "very", "really", "almost", "always",
    "never", "often", "sometimes", "usually", "early", "late",
    "here", "there", "now", "then", "today", "tomorrow",
    "yesterday", "soon", "already", "yet", "still", "even", NULL
};

// List of valid C functions and identifiers
const char *cValidIdentifiers[] = {
    "printf", "scanf", "main", "malloc", "free", "strlen", "strcpy", "strcmp",
    "num1", "num2", "result", "MAX", NULL
};

// List of valid Python functions and identifiers
const char *pythonValidIdentifiers[] = {
    "print", "input", "len", "range", "sum", "max", "min", "sorted",
    "calculate_average", "numbers", "average", "total", "count", NULL
};

// List of valid SQL functions and identifiers
const char *sqlValidIdentifiers[] = {
    // Table names
    "users", "customers", "orders", "products", "employees",
    
    // Column names
    "name", "age", "id", "email", "address", "phone", "price", "quantity",
    "date", "status", "description", "category", "total", "orderdate",
    "order_date", "customer_id", "product_id", "order_id", "amount",
    "total_price", "shipping_address", "billing_address", "payment_method",
    "order_status", "created_at", "updated_at", "first_name", "last_name",
    "username", "password", "role", "permission", "department", "salary",
    "hire_date", "manager_id", "location", "city", "state", "country",
    "zip_code", "product_name", "product_description", "product_price",
    "stock_quantity", "supplier_id", "supplier_name", "supplier_contact",
    "supplier_address", "invoice_number", "invoice_date", "due_date",
    "payment_status", "discount", "tax", "shipping_cost", "grand_total",
    
    // Data types
    "INT", "VARCHAR", "PRIMARY", "KEY",
    
    // Table aliases
    "o", "c", "p",
    
    NULL
};

// Error reporting function
void report_error(const char *message, const char *token) {
    fprintf(stderr, "Error at line %d, column %d: %s '%s'\n", 
            line_num, column_num, message, token);
    error_count++;
    exit(1); // Terminate immediately on error
}

// Function to check if a string is in a keyword list
int isInList(const char *word, const char **list) {
    for (int i = 0; list[i] != NULL; i++) {
        if (strcasecmp(word, list[i]) == 0) return 1;
    }
    return 0;
}

// Function to check if a token is a valid C identifier
int isValidCIdentifier(const char *token) {
    // Check if it's a C keyword
    const char *cKeywords[] = {
        "auto", "break", "case", "char", "const", "continue",
        "default", "do", "double", "else", "enum", "extern",
        "float", "for", "goto", "if", "int", "long",
        "register", "return", "short", "signed", "sizeof", "static",
        "struct", "switch", "typedef", "union", "unsigned", "void",
        "volatile", "while", NULL
    };

    // First check if it's a keyword
    for (int i = 0; cKeywords[i] != NULL; i++) {
        if (strcmp(token, cKeywords[i]) == 0) {
            return 2; // Valid C keyword
        }
    }

    // Then check if it's in our list of valid identifiers
    for (int i = 0; cValidIdentifiers[i] != NULL; i++) {
        if (strcmp(token, cValidIdentifiers[i]) == 0) {
            return 1; // Valid C identifier
        }
    }

    return 0; // Not a valid identifier
}

// Function to check if a token is a valid Python identifier
int isValidPythonIdentifier(const char *token) {
    // Check if it's a Python keyword
    const char *pythonKeywords[] = {
        "False", "None", "True", "and", "as", "assert",
        "async", "await", "break", "class", "continue", "def",
        "del", "elif", "else", "except", "finally", "for",
        "from", "global", "if", "import", "in", "is",
        "lambda", "nonlocal", "not", "or", "pass", "raise",
        "return", "try", "while", "with", "yield", NULL
    };

    // First check if it's a keyword
    for (int i = 0; pythonKeywords[i] != NULL; i++) {
        if (strcmp(token, pythonKeywords[i]) == 0) {
            return 2; // Valid Python keyword
        }
    }

    // Then check if it's in our list of valid identifiers
    for (int i = 0; pythonValidIdentifiers[i] != NULL; i++) {
        if (strcmp(token, pythonValidIdentifiers[i]) == 0) {
            return 1; // Valid Python identifier
        }
    }

    return 0; // Not a valid identifier
}

// Function to check if a token is a valid SQL identifier
int isValidSQLIdentifier(const char *token) {
    // Check if it's a SQL keyword
    const char *sqlKeywords[] = {
        "SELECT", "FROM", "WHERE", "INSERT", "UPDATE", "DELETE",
        "CREATE", "DROP", "TABLE", "VALUES", "INTO", "SET",
        "JOIN", "ON", "GROUP BY", "HAVING", "ORDER BY", "LIMIT",
        "OFFSET", "DISTINCT", "UNION", "INTERSECT", "EXCEPT",
        "AND", "OR", "NOT", "IN", "BETWEEN", "LIKE", "IS", NULL
    };

    // First check if it's a keyword
    for (int i = 0; sqlKeywords[i] != NULL; i++) {
        if (strcasecmp(token, sqlKeywords[i]) == 0) {
            return 2; // Valid SQL keyword
        }
    }

    // Then check if it's in our list of valid identifiers
    for (int i = 0; sqlValidIdentifiers[i] != NULL; i++) {
        if (strcasecmp(token, sqlValidIdentifiers[i]) == 0) {
            return 1; // Valid SQL identifier
        }
    }

    return 0; // Not a valid identifier
}

// Function to get token type based on current mode
const char* getTokenType(const char *value) {
    int result;
    switch(current_mode) {
        case MODE_SQL:
            result = isValidSQLIdentifier(value);
            if (result == 2) return "KEYWORD";
            if (result == 1) return "IDENTIFIER";
            report_error("Undefined token", value);
            break;
        case MODE_C:
            result = isValidCIdentifier(value);
            if (result == 2) return "KEYWORD";
            if (result == 1) return "IDENTIFIER";
            report_error("Undefined token", value);
            break;
        case MODE_PYTHON:
            result = isValidPythonIdentifier(value);
            if (result == 2) return "KEYWORD";
            if (result == 1) return "IDENTIFIER";
            report_error("Undefined token", value);
            break;
        case MODE_ENGLISH:
            if (isInList(value, englishPronouns)) return "PRONOUN";
            if (isInList(value, englishAdjectives)) return "ADJECTIVE";
            if (isInList(value, englishAdverbs)) return "ADVERB";
            // Simple verb detection
            if (strlen(value) > 2 && 
                (value[strlen(value)-1] == 's' || 
                 strstr(value, "ing") || 
                 strstr(value, "ed"))) {
                return "VERB";
            }
            return "NOUN";
    }

    if (isdigit(value[0])) {
        return "NUMBER";
    } else if (value[0] == '\'' || value[0] == '"') {
        return "STRING";
    } else if (strcmp(value, ";") == 0 || strcmp(value, ",") == 0 ||
               strcmp(value, "(") == 0 || strcmp(value, ")") == 0 ||
               strcmp(value, "{") == 0 || strcmp(value, "}") == 0 ||
               strcmp(value, "[") == 0 || strcmp(value, "]") == 0 ||
               strcmp(value, ".") == 0 || strcmp(value, ":") == 0) {
        return "SYMBOL";
    } else if (strcmp(value, "=") == 0 || strcmp(value, ">") == 0 || 
               strcmp(value, "<") == 0 || strcmp(value, "!=") == 0 ||
               strcmp(value, ">=") == 0 || strcmp(value, "<=") == 0 ||
               strcmp(value, "+") == 0 || strcmp(value, "-") == 0 ||
               strcmp(value, "*") == 0 || strcmp(value, "/") == 0 ||
               strcmp(value, "**") == 0 || strcmp(value, "//") == 0 ||
               strcmp(value, "+=") == 0 || strcmp(value, "-=") == 0 ||
               strcmp(value, "*=") == 0 || strcmp(value, "/=") == 0 ||
               strcmp(value, "==") == 0 || strcmp(value, "and") == 0 ||
               strcmp(value, "or") == 0 || strcmp(value, "not") == 0 ||
               strcmp(value, "is") == 0 || strcmp(value, "in") == 0 ||
               strcmp(value, "AND") == 0 || strcmp(value, "OR") == 0 ||
               strcmp(value, "NOT") == 0 || strcmp(value, "IN") == 0 ||
               strcmp(value, "BETWEEN") == 0 || strcmp(value, "LIKE") == 0) {
        return "OPERATOR";
    }
    
    return "IDENTIFIER";
}

void countEnglishWord(const char *word) {
    const char *type = getTokenType(word);
    if (strcmp(type, "NOUN") == 0) noun_count++;
    else if (strcmp(type, "PRONOUN") == 0) pronoun_count++;
    else if (strcmp(type, "ADJECTIVE") == 0) adjective_count++;
    else if (strcmp(type, "VERB") == 0) verb_count++;
    else if (strcmp(type, "ADVERB") == 0) adverb_count++;
}

// Function to check if a token is undefined in current language
int isUndefinedToken(const char *token) {
    switch(current_mode) {
        case MODE_C:
            // Check for C-specific undefined tokens
            if (strcmp(token, "->") == 0 || strcmp(token, "::") == 0 || 
                strcmp(token, "++") == 0 || strcmp(token, "--") == 0 ||
                strcmp(token, "&&") == 0 || strcmp(token, "||") == 0 ||
                strcmp(token, "!=") == 0 || strcmp(token, "==") == 0 ||
                strcmp(token, "+=") == 0 || strcmp(token, "-=") == 0 ||
                strcmp(token, "*=") == 0 || strcmp(token, "/=") == 0 ||
                strcmp(token, "%=") == 0 || strcmp(token, "&=") == 0 ||
                strcmp(token, "|=") == 0 || strcmp(token, "^=") == 0 ||
                strcmp(token, "<<") == 0 || strcmp(token, ">>") == 0 ||
                strcmp(token, "<<=") == 0 || strcmp(token, ">>=") == 0 ||
                strcmp(token, "?") == 0 || strcmp(token, ":") == 0) {
                return 0; // Valid C token
            }
            // Check for C keywords
            if (strcmp(token, "auto") == 0 || strcmp(token, "break") == 0 ||
                strcmp(token, "case") == 0 || strcmp(token, "char") == 0 ||
                strcmp(token, "const") == 0 || strcmp(token, "continue") == 0 ||
                strcmp(token, "default") == 0 || strcmp(token, "do") == 0 ||
                strcmp(token, "double") == 0 || strcmp(token, "else") == 0 ||
                strcmp(token, "enum") == 0 || strcmp(token, "extern") == 0 ||
                strcmp(token, "float") == 0 || strcmp(token, "for") == 0 ||
                strcmp(token, "goto") == 0 || strcmp(token, "if") == 0 ||
                strcmp(token, "int") == 0 || strcmp(token, "long") == 0 ||
                strcmp(token, "register") == 0 || strcmp(token, "return") == 0 ||
                strcmp(token, "short") == 0 || strcmp(token, "signed") == 0 ||
                strcmp(token, "sizeof") == 0 || strcmp(token, "static") == 0 ||
                strcmp(token, "struct") == 0 || strcmp(token, "switch") == 0 ||
                strcmp(token, "typedef") == 0 || strcmp(token, "union") == 0 ||
                strcmp(token, "unsigned") == 0 || strcmp(token, "void") == 0 ||
                strcmp(token, "volatile") == 0 || strcmp(token, "while") == 0) {
                return 0; // Valid C keyword
            }
            // Check for valid C identifiers
            if (isalpha(token[0]) || token[0] == '_') {
                int i;
                for (i = 1; token[i] != '\0'; i++) {
                    if (!isalnum(token[i]) && token[i] != '_') {
                        return 1; // Invalid character in identifier
                    }
                }
                return 0; // Valid C identifier
            }
            break;
            
        case MODE_PYTHON:
            // Check for Python-specific undefined tokens
            if (strcmp(token, "//") == 0 || strcmp(token, "**") == 0 ||
                strcmp(token, "//=") == 0 || strcmp(token, "**=") == 0 ||
                strcmp(token, "is") == 0 || strcmp(token, "not") == 0 ||
                strcmp(token, "in") == 0 || strcmp(token, "and") == 0 ||
                strcmp(token, "or") == 0 || strcmp(token, "lambda") == 0 ||
                strcmp(token, "yield") == 0 || strcmp(token, "async") == 0 ||
                strcmp(token, "await") == 0) {
                return 0; // Valid Python token
            }
            break;
            
        case MODE_SQL:
            // Check for SQL-specific undefined tokens
            if (strcmp(token, "JOIN") == 0 || strcmp(token, "ON") == 0 ||
                strcmp(token, "GROUP BY") == 0 || strcmp(token, "HAVING") == 0 ||
                strcmp(token, "ORDER BY") == 0 || strcmp(token, "LIMIT") == 0 ||
                strcmp(token, "OFFSET") == 0 || strcmp(token, "DISTINCT") == 0 ||
                strcmp(token, "UNION") == 0 || strcmp(token, "INTERSECT") == 0 ||
                strcmp(token, "EXCEPT") == 0) {
                return 0; // Valid SQL token
            }
            break;
    }
    
    // Check for common undefined tokens
    if (strcmp(token, "~") == 0 || strcmp(token, "`") == 0 ||
        strcmp(token, "@") == 0 || strcmp(token, "#") == 0 ||
        strcmp(token, "$") == 0 || strcmp(token, "\\") == 0 ||
        strcmp(token, "|") == 0 || strcmp(token, "^") == 0 ||
        strcmp(token, "&") == 0 || strcmp(token, "*") == 0 ||
        strcmp(token, "(") == 0 || strcmp(token, ")") == 0 ||
        strcmp(token, "-") == 0 || strcmp(token, "+") == 0 ||
        strcmp(token, "=") == 0 || strcmp(token, "{") == 0 ||
        strcmp(token, "}") == 0 || strcmp(token, "[") == 0 ||
        strcmp(token, "]") == 0 || strcmp(token, ":") == 0 ||
        strcmp(token, ";") == 0 || strcmp(token, "\"") == 0 ||
        strcmp(token, "'") == 0 || strcmp(token, "<") == 0 ||
        strcmp(token, ">") == 0 || strcmp(token, ",") == 0 ||
        strcmp(token, ".") == 0 || strcmp(token, "?") == 0 ||
        strcmp(token, "/") == 0) {
        return 0; // Valid common token
    }
    
    return 1; // Token is undefined
}
%}

%option noyywrap

DIGIT       [0-9]
LETTER      [a-zA-Z]
ID          ({LETTER}|_)({LETTER}|{DIGIT}|_)*
NUMBER      {DIGIT}+
STRING      \'[^\']*\'|\"[^\"]*\"
OPERATOR    "="|">"|"<"|"!="|">="|"<="|"+"|"-"|"*"|"/"|"++"|"--"|"+="|"-="|"*="|"/="|"=="|"&&"|"||"
SYMBOL      [;(),{}[\].]
WHITESPACE  [ \t]+
NEWLINE     \n
COMMENT     --.*|"/*"([^*]|"*"+[^*/])*"*"+"/"
WORD        [a-zA-Z]+


C_PREPROCESSOR ^#[ \t]*[a-zA-Z]+
C_UNTERMINATED_COMMENT "/*"([^*]|"*"+[^*/])*"*"*$
C_INVALID_HEADER ^#[ \t]*include[ \t]*<[^>]*$


PYTHON_INDENT ^[ \t]+
PYTHON_INVALID_INDENT ^[ \t]*[^ \t\n]
PYTHON_UNTERMINATED_STRING \"[^"]*$|\'[^']*$
PYTHON_INVALID_IDENTIFIER [0-9]+[a-zA-Z_]+


SQL_UNTERMINATED_STRING \'[^\']*$
SQL_INVALID_IDENTIFIER [0-9]+[a-zA-Z_]+
SQL_INVALID_KEYWORD [a-zA-Z]+[0-9]+

%%

{COMMENT}   { 
                char *p = yytext;
                while (*p) {
                    if (*p == '\n') line_num++;
                    p++;
                }
                column_num = 1;
            }

{WHITESPACE} { column_num += yyleng; }

{NEWLINE}    { line_num++; column_num = 1; }

{STRING}     {
                if (current_mode == MODE_ENGLISH) {
                    countEnglishWord(yytext);
                } else {
                    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", 
                           column_num, line_num, yytext, "STRING", yytext);
                }
                column_num += yyleng;
            }

{OPERATOR}   {
                if (current_mode != MODE_ENGLISH) {
                    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", 
                           column_num, line_num, yytext, "OPERATOR", yytext);
                }
                column_num += yyleng;
            }

{SYMBOL}     {
                if (current_mode != MODE_ENGLISH) {
                    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", 
                           column_num, line_num, yytext, "SYMBOL", yytext);
                }
                column_num += yyleng;
            }

{NUMBER}     {
                if (current_mode != MODE_ENGLISH) {
                    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", 
                           column_num, line_num, yytext, "NUMBER", yytext);
                }
                column_num += yyleng;
            }

{ID}         {
                if (current_mode == MODE_ENGLISH) {
                    countEnglishWord(yytext);
                } else if (current_mode == MODE_C) {
                    if (!isValidCIdentifier(yytext)) {
                        report_error("Undefined token", yytext);
                    } else {
                        const char *type = getTokenType(yytext);
                        printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", 
                               column_num, line_num, yytext, type, yytext);
                    }
                } else {
                    const char *type = getTokenType(yytext);
                    printf("| %-6d | %-6d | %-15s | %-10s | %-12s |\n", 
                           column_num, line_num, yytext, type, yytext);
                }
                column_num += yyleng;
            }

{WORD}       {
                if (current_mode == MODE_ENGLISH) {
                    countEnglishWord(yytext);
                }
                column_num += yyleng;
            }

{C_PREPROCESSOR} {
    if (current_mode == MODE_C) {
        if (strstr(yytext, "include") && !strstr(yytext, "<") && !strstr(yytext, "\"")) {
            report_error("Invalid include directive", yytext);
        }
    }
    column_num += yyleng;
}

{C_UNTERMINATED_COMMENT} {
    if (current_mode == MODE_C) {
        report_error("Unterminated C comment", yytext);
    }
    column_num += yyleng;
}

{PYTHON_INDENT} {
    if (current_mode == MODE_PYTHON) {
        int spaces = 0;
        char *p = yytext;
        while (*p) {
            if (*p == ' ') spaces++;
            else if (*p == '\t') spaces += 4;
            p++;
        }
        if (spaces % 4 != 0) {
            report_error("Inconsistent indentation", yytext);
        }
    }
    column_num += yyleng;
}

{PYTHON_UNTERMINATED_STRING} {
    if (current_mode == MODE_PYTHON) {
        report_error("Unterminated Python string", yytext);
    }
    column_num += yyleng;
}

{PYTHON_INVALID_IDENTIFIER} {
    if (current_mode == MODE_PYTHON) {
        report_error("Invalid Python identifier (cannot start with number)", yytext);
    }
    column_num += yyleng;
}

{SQL_UNTERMINATED_STRING} {
    if (current_mode == MODE_SQL) {
        report_error("Unterminated SQL string", yytext);
    }
    column_num += yyleng;
}

{SQL_INVALID_IDENTIFIER} {
    if (current_mode == MODE_SQL) {
        report_error("Invalid SQL identifier (cannot start with number)", yytext);
    }
    column_num += yyleng;
}

{SQL_INVALID_KEYWORD} {
    if (current_mode == MODE_SQL) {
        report_error("Invalid SQL keyword format", yytext);
    }
    column_num += yyleng;
}

.            {
                if (current_mode != MODE_ENGLISH) {
                    report_error("Invalid character", yytext);
                }
                column_num += yyleng;
            }

%%

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <filename> [mode]\n", argv[0]);
        fprintf(stderr, "Modes: sql (default), c, python, english\n");
        return 1;
    }

    // Determine mode from filename extension or explicit mode
    char *ext = strrchr(argv[1], '.');
    if (ext != NULL) {
        ext++;
        if (strcmp(ext, "c") == 0) current_mode = MODE_C;
        else if (strcmp(ext, "py") == 0) current_mode = MODE_PYTHON;
        else if (strcmp(ext, "sql") == 0) current_mode = MODE_SQL;
        else if (strcmp(ext, "txt") == 0) current_mode = MODE_ENGLISH;
    }

    // Override with explicit mode if provided
    if (argc > 2) {
        if (strcmp(argv[2], "c") == 0) current_mode = MODE_C;
        else if (strcmp(argv[2], "python") == 0) current_mode = MODE_PYTHON;
        else if (strcmp(argv[2], "sql") == 0) current_mode = MODE_SQL;
        else if (strcmp(argv[2], "english") == 0) current_mode = MODE_ENGLISH;
    }

    printf("| Column | Line   | Lexeme          | Token      | Token Value  |\n");
    printf("|--------|--------|-----------------|------------|--------------|\n");

    yyin = fopen(argv[1], "r");
    if (!yyin) {
        fprintf(stderr, "Error: Cannot open file %s\n", argv[1]);
        return 1;
    }

    yylex();

    fclose(yyin);

    if (error_count > 0) {
        fprintf(stderr, "\nTotal errors found: %d\n", error_count);
        return 1;
    }

    if (current_mode == MODE_ENGLISH) {
        printf("\nEnglish Text Analysis Summary:\n");
        printf("| %-8s | %-8s | %-11s | %-6s | %-7s |\n", 
               "Nouns", "Pronouns", "Adjectives", "Verbs", "Adverbs");
        printf("|---------|----------|------------|--------|---------|\n");
        printf("| %-8d | %-8d | %-11d | %-6d | %-7d |\n", 
               noun_count, pronoun_count, adjective_count, verb_count, adverb_count);
    }

    return 0;
}


//input.C

#define MAX 100

int main() {
    int num1 = 10, num2 = 20;
    float result;

    if (num1 > num2) {
        result = num1 * 1.5;
    } else {
        result = num2 / 2.0;
    }
    
    printf("Result\n", result);
    return 0;
}
//input.py
def calculate_average(numbers):
    """This function calculates the average"""
    total = sum(numbers)
    count = len(numbers)
    
    if count == 0:
        return 0  # Avoid division by zero
    else:
        return total / count

data = [10, 20, 30, 40, 50]
average = calculate_average(data)

print(f"The average is: {average:.2f}")

//input.sql
SELECT name, age FROM users WHERE age > 21;

INSEasdasRT INTO customers VALUES ('John Doe', 35, 'john@example.com');
UPDATE products 
SET price = price * 0.9 
WHERE category = 'electronics';

DELETE FROM orders WHERE order_date < '2023-01-01';

CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(100), department VARCHAR(50));
SELECT o.order_id, c.name, p.product_name
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN products p ON o.product_id = p.id
WHERE o.status = 'completed' AND p.category = 'books';

//name code first name  lex:
%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int name=0,lname=0;
int a[10];
const char *b[10]={"First Name","Last Name","Phone","Url","Email","Date","Time"};
void validate(char *type, char *value, int valid,int index) {
    if (valid && a[index]!=1){
        printf("%s VALID: %s\n", type, value);
        a[index]=1;
        if(index<=6){       
            printf("Enter %s ",b[index]);
        }else{
            exit(1);
        }
    }
    else if(a[index]==1){
        printf(type,"%s Already Entered");
        printf("Enter %s ",b[index]);
    }
    else{
        printf("%s INVALID: %s\n", type, value);
        printf("Enter %s Again",type);
    }
    
    
}
%}

%%


[A-Z][a-z]+  { validate("First Name", yytext, 1,1); }
[A-Za-z]+    { validate("First Name", yytext, 0,1); }  

[" "][A-Z][a-z]+  { validate("Last Name", yytext, 1,2); }
[" "][A-Za-z]+    { validate("Last Name", yytext, 0,2); }  

[0-9]{10}    { validate("PHONE", yytext, 1,3); }
[0-9]+       { validate("PHONE", yytext, 0,3); }


"https://"[a-zA-Z0-9./]+ { validate("URL", yytext, 1,4); }    
"https?://"[^ ]+         { validate("URL", yytext, 0,4); } 


[a-zA-Z0-9._%+-]+@gmail\.com { validate("EMAIL", yytext, 1,5); }
[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+ { validate("EMAIL", yytext, 0,5); } 


(0[1-9]|[12][0-9]|3[01])-(0[1-9]|1[0-2])-[0-9]{4} { validate("DATE", yytext, 1, 6); }
[0-9-]+ { validate("DATE", yytext, 0, 6); }
([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9] { validate("TIME", yytext, 1,7); }
[0-9:]+ { validate("TIME", yytext, 0,7); }


.   {  }

%%

int main() {
   // printf("Enter First Name \nEnter Last Name\nEnter Phone Number\nEnter url\nEnter email\nEnter Date\nEnter time:\n");
    //yylex();  
    printf("Enter First Name: ");
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}

//word count word appears in a paragraph
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_WORDS 1000
#define MAX_LINES 100

typedef struct {
    char word[100];
    int count;
    int lines[MAX_LINES];
    int lineCount;
} WordEntry;

WordEntry words[MAX_WORDS];
int word_count = 0;
int line_no = 1;

void toLower(char *s) {
    for (int i = 0; s[i]; i++) {
        s[i] = tolower(s[i]);
    }
}

void addWord(char *text) {
    toLower(text);
    for (int i = 0; i < word_count; i++) {
        if (strcmp(words[i].word, text) == 0) {
            words[i].count++;
            if (words[i].lines[words[i].lineCount - 1] != line_no) {
                words[i].lines[words[i].lineCount++] = line_no;
            }
            return;
        }
    }
    strcpy(words[word_count].word, text);
    words[word_count].count = 1;
    words[word_count].lines[0] = line_no;
    words[word_count].lineCount = 1;
    word_count++;
}
%}

%%
[a-zA-Z]+       { addWord(yytext); }
\n              { line_no++; }
[ \t\r]+        { /* ignore whitespace */ }
.               { /* ignore punctuation */ }
%%

int yywrap() {
    return 1;
}

int main(int argc, char **argv) {
    FILE *file = fopen("input.txt", "r");
    if (!file) {
        printf("Could not open the file!\n");
        return 1;
    }

    yyin = file;
    yylex();
    fclose(file);

    printf("\nWord\t\tCount\tLine Numbers\n");
    printf("-------------------------------------------------------------\n");
    for (int i = 0; i < word_count; i++) {
        printf("%-15s\t%-5d\t", words[i].word, words[i].count);
        for (int j = 0; j < words[i].lineCount; j++) {
            printf("%d ", words[i].lines[j]);
        }
        printf("\n");
    }

    return 0;
}

//steps to run
flex lexer.l
gcc lex.yy.c -o count.exe
.\count.exe
//input.txt
Hello world
This is a test.
Hello again world.

//code for switch statement syntax
lex.l
%{
#include "parser.tab.h"
#include <string.h>
#include <stdlib.h>

#ifndef strdup
char *strdup(const char *s) {
    char *d = malloc(strlen(s) + 1);
    if (d == NULL) return NULL;
    strcpy(d, s);
    return d;
}
#endif
%}

%%

"switch"      { return SWITCH; }
"case"        { return CASE; }
"default"     { return DEFAULT; }
"break"       { return BREAK; }
"{"           { return LBRACE; }
"}"           { return RBRACE; }
":"           { return COLON; }
";"           { return SEMICOLON; }
[0-9]+        { yylval.str = strdup(yytext); return NUMBER; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.str = strdup(yytext); return ID; }
[ \t\n]+      { /* ignore whitespace */ }
.             { return yytext[0]; }

%%

int yywrap() { return 1; } 

//parser.y

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void yyerror(const char *s);
int yylex();
void print_indent(int level);
int indent = 0;
%}

%union {
    char* str;
}
%token <str> ID NUMBER
%token SWITCH CASE DEFAULT BREAK LBRACE RBRACE COLON SEMICOLON ASSIGN

%%

program:
    switch_stmt
    ;

switch_stmt:
    SWITCH '(' expr ')' LBRACE case_list RBRACE {
        print_indent(indent); printf("|-- switch_stmt\n");
        indent++;
        print_indent(indent); printf("|-- SWITCH\n");
        print_indent(indent); printf("|-- expr\n");
        indent++;
        // expr prints itself
        indent--;
        print_indent(indent); printf("|-- case_list\n");
        indent++;
        // case_list prints itself
        indent--;
        indent--;
    }
    ;

case_list:
    case_list case_stmt
    | case_stmt
    ;

case_stmt:
    CASE NUMBER COLON stmt_list BREAK SEMICOLON {
        print_indent(indent); printf("|-- case_stmt\n");
        indent++;
        print_indent(indent); printf("|-- CASE\n");
        print_indent(indent); printf("|-- NUMBER: %s\n", $2);
        print_indent(indent); printf("|-- stmt_list\n");
        indent++;
        // stmt_list prints itself
        indent--;
        print_indent(indent); printf("|-- BREAK\n");
        print_indent(indent); printf("|-- SEMICOLON\n");
        indent--;
    }
    | DEFAULT COLON stmt_list BREAK SEMICOLON {
        print_indent(indent); printf("|-- default_stmt\n");
        indent++;
        print_indent(indent); printf("|-- DEFAULT\n");
        print_indent(indent); printf("|-- stmt_list\n");
        indent++;
        // stmt_list prints itself
        indent--;
        print_indent(indent); printf("|-- BREAK\n");
        print_indent(indent); printf("|-- SEMICOLON\n");
        indent--;
    }
    ;

stmt_list:
    stmt_list stmt
    | stmt
    ;

stmt:
    ID ASSIGN expr SEMICOLON {
        print_indent(indent); printf("|-- stmt\n");
        indent++;
        print_indent(indent); printf("|-- ID: %s\n", $1);
        print_indent(indent); printf("|-- ASSIGN\n");
        print_indent(indent); printf("|-- expr\n");
        indent++;
        // expr prints itself
        indent--;
        print_indent(indent); printf("|-- SEMICOLON\n");
        indent--;
    }
    ;

expr:
    NUMBER { print_indent(indent); printf("|-- NUMBER: %s\n", $1); }
    | ID { print_indent(indent); printf("|-- ID: %s\n", $1); }
    ;

%%

void yyerror(const char *s) {
    printf("Error: %s\n", s);
}

void print_indent(int level) {
    for (int i = 0; i < level; i++) printf("    ");
}

int main() {
    printf("Enter a switch statement:\n");
    yyparse();
    return 0;
} 
//note in cmd not powershell
bison -d parser.y
flex lexical.l
gcc parser.tab.c lex.yy.c -o switch.exe
switch.exe < input.txt

//input
switch (x) {
case 1: y = 10; break;
case 2: y = 20; break;
default: y = 0; break;
}
or you can type the input if you jsut run the exe without input file
//code for english language syntax
//lex.l
%{
#include "parser.tab.h"
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdio.h>   

#ifndef strdup
char *strdup(const char *s) {
    char *d = malloc(strlen(s) + 1);
    if (d == NULL) return NULL;
    strcpy(d, s);
    return d;
}
#endif

// Convert to lowercase for case-insensitive match
char *to_lower(const char *s) {
    char *lower = strdup(s);
    if (lower == NULL) return NULL;   // <-- Avoid NULL dereference
    for (int i = 0; lower[i]; i++) {
        lower[i] = tolower((unsigned char)lower[i]);
    }
    return lower;
}
%}

%%

[aA]|[tT][hH][eE] {
    char *word = to_lower(yytext);
    yylval.str = word;
    return ARTICLE;
}

[bB][lL][aA][cC][kK]|[wW][hH][iI][tT][eE]|[hH][aA][pP][pP][yY]|[aA][nN][gG][rR][yY] {
    yylval.str = to_lower(yytext);
    return ADJECTIVE;
}

[cC][aA][tT][sS]?|[dD][oO][gG][sS]?|[fF][iI][sS][hH]|[fF][oO][oO][dD][sS]? {
    yylval.str = to_lower(yytext);
    return NOUN;
}

[eE][aA][tT][sS]?|[lL][oO][vV][eE][sS]?|[hH][aA][tT][eE][sS]? {
    yylval.str = to_lower(yytext);
    return VERB;
}

[ \t\r\n]+   { /* skip whitespace */ }
[.?!]        { /* ignore punctuation */ }

[a-zA-Z]+    {
    char *word = to_lower(yytext);
   // printf("Unknown word: %s\n", word);
    free(word);
    return 0;
}

.            { return yytext[0]; }

.[!@#$%^&*|]  {  
    printf("unidentified token\n");
    exit(0);
}

%%

int yywrap() { return 1; }

//parser.y:
%{
#include <stdio.h>
#include <stdlib.h>

void yyerror(const char *s);
int yylex();
%}

%union {
    char* str;
}

%token <str> ARTICLE NOUN VERB ADJECTIVE
%type <str> sentence opt_adj


%%

sentence:
    ARTICLE opt_adj NOUN VERB NOUN {
        printf("Valid sentence structure:\n");
        printf("Article: %s\n", $1);
        if ($2) printf("Adjective: %s\n", $2);
        printf("Subject: %s\n", $3);
        printf("Verb: %s\n", $4);
        printf("Object: %s\n", $5);
    }
    ;

opt_adj:
    /* empty */    { $$ = NULL; }
    | ADJECTIVE    { $$ = $1; }
    ;

%%

void yyerror(const char *s) {
    printf("Syntax error: %s\n", s);
}

int main() {
    printf("Enter a sentence:\n");
    yyparse();
    return 0;
}

//input:
inp:
A happy dogs eats food! [correct]

Happy dog eats fish [wrong,missing article]

//steps to run
bison -d parser.y          
flex lex.l                  
gcc parser.tab.c lex.yy.c -o english_parser.exe
english_parser.exe

//ifelse if else syntax code:
lex.l
%{
#include "parser.tab.h"
#include <string.h>
#include <stdlib.h>

#ifndef strdup
char *strdup(const char *s) {
    char *d = malloc(strlen(s) + 1);   // allocate memory
    if (d == NULL) return NULL;        // check for malloc failure
    strcpy(d, s);                      // copy string
    return d;
}
#endif
%}

%%

"if"         { return IF; }
"else"       { return ELSE; }
"("          { return LPAREN; }
")"          { return RPAREN; }
"{"          { return LBRACE; }
"}"          { return RBRACE; }
[0-9]+       { yylval.str = strdup(yytext); return NUMBER; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.str = strdup(yytext); return ID; }
"="          { return ASSIGN; }
"=="         { return EQ; }
"<"          { return LT; }
">"          { return GT; }
"+"          { return PLUS; }
"-"          { return MINUS; }
"*"          { return MUL; }
"/"          { return DIV; }
";"          { return SEMICOLON; }
[ \t\n]+     { /* ignore whitespace */ }
.            { return yytext[0]; }

%%

int yywrap() { return 1; }

//parser.y
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  

void yyerror(const char *s);
int yylex();
void print_indent(int level);
int indent = 0; // Global indent level
%}

%union {
    char* str;    // for ID and others
}
%token <str> ID NUMBER

/* Declare operator precedence */
%left PLUS MINUS
%left MUL DIV
%left LT GT EQ

%token IF ELSE LPAREN RPAREN LBRACE RBRACE EQ LT GT PLUS MINUS MUL DIV SEMICOLON ASSIGN

%%

program:
    if_else_stmt {
        indent++;
        /* if_else_stmt printing is handled by its own action */
        indent--;
    }
    ;

if_else_stmt:
    IF LPAREN condition RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE {
        print_indent(indent);
        printf("|-- if_else_stmt\n");
        indent++;
            print_indent(indent);
            printf("|-- IF\n");
            print_indent(indent);
            printf("|-- condition\n");
            indent++;
                /* condition rule prints its structure */
            indent--;
            print_indent(indent);
            printf("|-- stmt_list (if-block)\n");
            indent++;
                /* if stmt_list rule prints its structure */
            indent--;
            print_indent(indent);
            printf("|-- ELSE\n");
            print_indent(indent);
            printf("|-- stmt_list (else-block)\n");
            indent++;
                /* else stmt_list rule prints its structure */
            indent--;
        indent--;
    }
    ;

condition:
    expr LT expr {
        print_indent(indent);
        printf("|-- condition\n");
        indent++;
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Left expr printed by expr rule */
            indent--;
            print_indent(indent);
            printf("|-- LT\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Right expr printed by expr rule */
            indent--;
        indent--;
    }
    | expr GT expr {
        print_indent(indent);
        printf("|-- condition\n");
        indent++;
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Left expr printed by expr rule */
            indent--;
            print_indent(indent);
            printf("|-- GT\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Right expr printed by expr rule */
            indent--;
        indent--;
    }
    | expr EQ expr {
        print_indent(indent);
        printf("|-- condition\n");
        indent++;
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Left expr printed by expr rule */
            indent--;
            print_indent(indent);
            printf("|-- EQ\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Right expr printed by expr rule */
            indent--;
        indent--;
    }
    ;

stmt_list:
    stmt {
        print_indent(indent);
        printf("|-- stmt_list\n");
        indent++;
            print_indent(indent);
            printf("|-- stmt\n");
        indent--;
    }
    | stmt_list stmt {
        print_indent(indent);
        printf("|-- stmt_list\n");
        indent++;
            print_indent(indent);
            printf("|-- stmt\n");
        indent--;
    }
    ;

stmt:
    ID ASSIGN expr SEMICOLON {
        print_indent(indent);
        printf("|-- stmt\n");
        indent++;
            print_indent(indent);
            printf("|-- ID: %s\n", $1);
            print_indent(indent);
            printf("|-- ASSIGN\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* expr already prints its contents */
            indent--;
            print_indent(indent);
            printf("|-- SEMICOLON\n");
        indent--;
    }
    ;

expr:
    expr PLUS expr {
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Left expr printed by expr rule */
            indent--;
            print_indent(indent);
            printf("|-- PLUS\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Right expr printed by expr rule */
            indent--;
        indent--;
    }
    | expr MINUS expr {
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Left expr printed by expr rule */
            indent--;
            print_indent(indent);
            printf("|-- MINUS\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Right expr printed by expr rule */
            indent--;
        indent--;
    }
    | expr MUL expr {
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Left expr printed by expr rule */
            indent--;
            print_indent(indent);
            printf("|-- MUL\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Right expr printed by expr rule */
            indent--;
        indent--;
    }
    | expr DIV expr {
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Left expr printed by expr rule */
            indent--;
            print_indent(indent);
            printf("|-- DIV\n");
            print_indent(indent);
            printf("|-- expr\n");
            indent++;
                /* Right expr printed by expr rule */
            indent--;
        indent--;
    }
    | ID {
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            print_indent(indent);
            printf("|-- ID: %s\n", $1);
        indent--;
    }
    | NUMBER {
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            print_indent(indent);
            printf("|-- NUMBER: %s\n", $1);
        indent--;
    }
    ;

%%

void yyerror(const char *s) {
    printf("Error: %s\n", s);
}

void print_indent(int level) {
    for (int i = 0; i < level; i++) {
        printf("    ");
    }
}

int main() {
    printf("Enter an if-else statement:\n");
    yyparse();
    return 0;
}
//input
[correct]if (x < 10) { x = x + 1; } else { x = x - 1; }  
[wrong]if (x > 5) { x = x + 1; y = y * 2; } else { x = x - 1; z = 0; }

//steps to run
flex lex.l
bison -d parser.y
gcc lex.yy.c parser.tab.c -o ifelse_parser
./ifelse_parser


//minimal ifelse code

//lex.l
%{
#include "parser.tab.h"
#include <string.h>
#include <stdlib.h>

#ifndef strdup
char *strdup(const char *s) {
    char *d = malloc(strlen(s) + 1);
    if (d == NULL) return NULL;
    strcpy(d, s);
    return d;
}
#endif
%}

%%

"if"         { return IF; }
"else"       { return ELSE; }
"("          { return LPAREN; }
")"          { return RPAREN; }
"{"          { return LBRACE; }
"}"          { return RBRACE; }
[0-9]+       { yylval.str = strdup(yytext); return NUMBER; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.str = strdup(yytext); return ID; }
"="          { return ASSIGN; }
"=="         { return EQ; }
"<"          { return LT; }
">"          { return GT; }
"+"          { return PLUS; }
"-"          { return MINUS; }
"*"          { return MUL; }
"/"          { return DIV; }
";"          { return SEMICOLON; }
[ \t\n]+     { /* ignore whitespace */ }
.            { return yytext[0]; }

%%

int yywrap() { return 1; }

//parser.y
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  

void yyerror(const char *s);
int yylex();
void print_indent(int level);
void print_condition(const char* op);
void print_stmt(const char* stmt);
char* concat(const char* s1, const char* s2, const char* s3);
int indent = 0;
%}

%union {
    char* str;
    const char* op;
}

%token <str> ID NUMBER
%token IF ELSE LPAREN RPAREN LBRACE RBRACE EQ LT GT PLUS MINUS MUL DIV SEMICOLON ASSIGN

%type <op> condition
%type <str> expr stmt_list
%type <str> stmt

%left PLUS MINUS
%left MUL DIV
%left LT GT EQ

%%

program:
    if_else_stmt { }
    ;

if_else_stmt:
    IF LPAREN condition RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE {
        print_indent(indent);
        printf("if-else\n");
        indent++;
            print_indent(indent);
            printf("condition: ");
            print_condition($3);
            print_indent(indent);
            printf("if-block:\n");
            indent++;
                print_stmt($6);
            indent--;
            print_indent(indent);
            printf("else-block:\n");
            indent++;
                print_stmt($10);
            indent--;
        indent--;
        free($6);
        free($10);
    }
    ;

condition:
    expr LT expr { $$ = "<"; free($1); free($3); }
    | expr GT expr { $$ = ">"; free($1); free($3); }
    | expr EQ expr { $$ = "=="; free($1); free($3); }
    ;

stmt_list:
    stmt { $$ = $1; }
    | stmt_list stmt { 
        $$ = concat($1, "\n", $2);
        free($1);
        free($2);
      }
    ;

stmt:
    ID ASSIGN expr SEMICOLON {
        $$ = concat($1, " = ", $3);
        free($1);
        free($3);
    }
    ;

expr:
    expr PLUS expr { $$ = concat($1, " + ", $3); }
    | expr MINUS expr { $$ = concat($1, " - ", $3); }
    | expr MUL expr { $$ = concat($1, " * ", $3); }
    | expr DIV expr { $$ = concat($1, " / ", $3); }
    | ID { $$ = strdup($1); }
    | NUMBER { $$ = strdup($1); }
    ;

%%

void print_condition(const char* op) {
    printf("%s\n", op);
}

void print_stmt(const char* stmt) {
    print_indent(indent);
    printf("%s\n", stmt);
}

char* concat(const char* s1, const char* s2, const char* s3) {
    char* result = malloc(strlen(s1) + strlen(s2) + strlen(s3) + 1);
    strcpy(result, s1);
    strcat(result, s2);
    strcat(result, s3);
    return result;
}

void print_indent(int level) {
    for (int i = 0; i < level; i++) {
        printf("  ");
    }
}

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

int main() {
    printf("Enter an if-else statement:\n");
    yyparse();
    return 0;
}

//input
if (x < 10) { x = x + 1; } else { x = x - 1; }
if (x > 5) { x = x + 1; y = y * 2; } else { x = x - 1; z = 0; }


//steps to run
flex lex.l
bison -d parser.y
gcc lex.yy.c parser.tab.c -o ifelse_parser
./ifelse_parser

//sql syntax code

//lex.l
%{
#include "parser.tab.h"
#include <string.h>
#include <stdlib.h>

#ifndef strdup
char *strdup(const char *s) {
    char *d = malloc(strlen(s) + 1);
    if (d == NULL) return NULL;
    strcpy(d, s);
    return d;
}
#endif
%}

%%

"SELECT"            { return SELECT; }
"FROM"              { return FROM; }
","                 { return COMMA; }
";"                 { return SEMICOLON; }
[a-zA-Z_][a-zA-Z0-9_]*  { yylval.str = strdup(yytext); return IDENTIFIER; }
[ \t\r\n]+          { /* skip whitespace */ }
.                   { return yytext[0]; }

%%
int yywrap() { return 1; }

//parser.y
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void yyerror(const char *s);
int yylex();
void print_indent(int level);
int indent = 0;
%}

%union {
    char* str;
}

%token <str> IDENTIFIER
%token SELECT FROM COMMA SEMICOLON

%%

query:
    SELECT select_list FROM IDENTIFIER SEMICOLON {
        print_indent(indent);
        printf("|-- SELECT statement\n");
        indent++;
        print_indent(indent);
        printf("|-- Columns:\n");
        indent++;
        // Columns printed in select_list rule
        indent--;
        print_indent(indent);
        printf("|-- Table: %s\n", $4);
        indent--;
    }
    ;

select_list:
    IDENTIFIER {
        print_indent(indent);
        printf("|-- Column: %s\n", $1);
    }
    | select_list COMMA IDENTIFIER {
        print_indent(indent);
        printf("|-- Column: %s\n", $3);
    }
    ;

%%

void yyerror(const char *s) {
    printf("Syntax Error: %s\n", s);
}

void print_indent(int level) {
    for (int i = 0; i < level; i++) {
        printf("    ");
    }
}

int main() {
    printf("Enter a SELECT statement:\n");
    yyparse();
    return 0;
}

//input
SELECT name, age FROM users;
SELECT name, age FROM users [wrong]

//steps to run
bison -d parser.y            
flex lex.l                   
gcc parser.tab.c lex.yy.c -o sql_parser.exe 
sql_parser.exe              


//while statement syntax 

//lex.l 
%{
#include "paser.tab.h"
#include <string.h>
#include <stdlib.h>

#ifndef strdup
char *strdup(const char *s) {
    char *d = malloc(strlen(s) + 1);   // allocate memory
    if (d == NULL) return NULL;        // check for malloc failure
    strcpy(d, s);                      // copy string
    return d;
}
#endif
%}


%%

"while"      { return WHILE; }
"("          { return LPAREN; }
")"          { return RPAREN; }
"{"          { return LBRACE; }
"}"          { return RBRACE; }
[0-9]+       { yylval.str = strdup(yytext); return NUMBER; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.str = strdup(yytext); return ID; }
"="          { return ASSIGN; }
"=="         { return EQ; }
"<"          { return LT; }
">"          { return GT; }
"+"          { return PLUS; }
"-"          { return MINUS; }
"*"          { return MUL; }
"/"          { return DIV; }
";"          { return SEMICOLON; }
[ \t\n]+     { /* ignore whitespace */ }
.            { return yytext[0]; }

%%

int yywrap() { return 1; }

//parser.y 
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  

void yyerror(const char *s);
int yylex();
void print_indent(int level);
int indent = 0; // Global indent level
%}

%union {
    char* str;    // for ID and others
}
%token <str> ID NUMBER

/* Declare operator precedence */
%left PLUS MINUS
%left MUL DIV
%left LT GT EQ

%token WHILE LPAREN RPAREN LBRACE RBRACE EQ LT GT PLUS MINUS MUL DIV SEMICOLON ASSIGN

%%

program:
    while_stmt {
       //printf("\nParse Tree:\n");
       //printf("|-- program\n");
        indent++;
        /* while_stmt printing is handled by its own action */
        indent--;
    }
    ;

while_stmt:
    WHILE LPAREN condition RPAREN LBRACE stmt_list RBRACE {
        print_indent(indent);
        printf("|-- while_stmt\n");
        indent++;
            print_indent(indent);
            printf("|-- WHILE\n");
            print_indent(indent);
            printf("|-- condition\n");
            indent++;
                /* condition rule prints its structure */
            indent--;
            print_indent(indent);
            printf("|-- stmt_list\n");
            indent++;
                /* stmt_list rule prints its structure */
            indent--;
            print_indent(indent);
            printf("|-- RBRACE\n");
        indent--;
    }
    ;

condition:
    expr LT expr {
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            /* Left expr printed by expr rule */
        indent--;
        print_indent(indent);
        printf("|-- LT\n");
        print_indent(indent);
        printf("|-- expr\n");
        indent++;
            /* Right expr printed by expr rule */
        indent--;
    }
    ;

/* Use a standard left-recursive definition (without an empty alternative)
   to avoid reduce/reduce conflicts.
   In the base case, we simulate an extra branch showing an empty additional statement.
*/
stmt_list:
    stmt {
        print_indent(indent);
        printf("|-- stmt_list\n");
        indent++;
            /* Print the stmt details (already printed in stmt rule) */
            print_indent(indent);
            printf("|-- stmt\n");
            print_indent(indent+1);
            printf("|-- (empty, if any additional statement)\n");
        indent--;
    }
    | stmt_list stmt {
        print_indent(indent);
        printf("|-- stmt_list\n");
        indent++;
            print_indent(indent);
            printf("|-- stmt\n");
        indent--;
    }
    ;

expr:
    expr PLUS expr {
        print_indent(indent);
        printf("|-- expr + expr\n");
    }
    | ID {
        print_indent(indent);
        printf("|-- ID: %s\n", $1);
    }
    | NUMBER {
        print_indent(indent);
        printf("|-- NUMBER: %s\n", $1);
    }
    ;

stmt:
    ID ASSIGN expr SEMICOLON {
        print_indent(indent);
        printf("|-- stmt\n");
        indent++;
            print_indent(indent);
            printf("|-- ID: %s\n", $1);
            print_indent(indent);
            printf("|-- ASSIGN\n");
            /* expr already prints its contents */
            print_indent(indent);
            printf("|-- SEMICOLON\n");
        indent--;
    }


%%

void yyerror(const char *s) {
    printf("Error: %s\n", s);
}

void print_indent(int level) {
    for (int i = 0; i < level; i++) {
        printf("    ");
    }
}

int main() {
    printf("Enter a while statement:\n");
    yyparse();
    return 0;
}

//input
while (i < 5) { x = 10; }  [correct]
while (i < 5) { x = 10;    [wrong]

//steps to run
bison -d parser.y     
flex lexical.l         
gcc parser.tab.c lex.yy.c -o error.exe 
./error.exe            


//code for calculator

//lex.l 
%{
#include <stdio.h>
#include <stdlib.h>
#include "parser.tab.h"  // Correctly declares yylval as YYSTYPE
%}

%%

[0-9]+      { yylval.val = atoi(yytext); return NUMBER; }
[\t ]+      ;                 // Ignore whitespace
\n          return 0;         // End input on newline
.           return yytext[0]; // Return single characters

%%

int yywrap() {
    return 1;
}

//parser.y:
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int flag = 0;

int yylex(void);
void yyerror(const char *s);

typedef struct Node {
    char label[50];
    struct Node *left, *right;
    int val;
} Node;

// Function declarations
Node* createNode(const char *label, Node* left, Node* right);
void printParseTree(Node* root, int depth);
void freeTree(Node* root);

// Root of parse tree
Node* root = NULL;
%}

%union {
    int val;
    struct Node* node;
}

%token <val> NUMBER
%type  <node> E

%left '+' '-'
%left '*' '/' '%'
%left '(' ')'

%%

ArithmeticExpression:
    E {
        root = $1;
    }
;

E:
      E '+' E {
          $$ = createNode("+", $1, $3);
          $$->val = $1->val + $3->val;
      }
    | E '-' E {
          $$ = createNode("-", $1, $3);
          $$->val = $1->val - $3->val;
      }
    | E '*' E {
          $$ = createNode("*", $1, $3);
          $$->val = $1->val * $3->val;
      }
    | E '/' E {
          $$ = createNode("/", $1, $3);
          $$->val = $1->val / $3->val;
      }
    | E '%' E {
          $$ = createNode("%", $1, $3);
          $$->val = $1->val % $3->val;
      }
    | '(' E ')' {
          $$ = createNode("()", $2, NULL);
          $$->val = $2->val;
      }
    | NUMBER {
          char buffer[20];
          sprintf(buffer, "%d", $1);
          $$ = createNode(buffer, NULL, NULL);
          $$->val = $1;
      }
;

%%

Node* createNode(const char *label, Node* left, Node* right) {
    Node* newNode = (Node*) malloc(sizeof(Node));
    strcpy(newNode->label, label);
    newNode->left = left;
    newNode->right = right;
    newNode->val = 0;
    return newNode;
}

void printParseTree(Node* root, int depth) {
    if (!root) return;

    for (int i = 0; i < depth; i++)
        printf("  ");  // Two spaces per level

    printf("|-- %s\n", root->label);

    printParseTree(root->left, depth + 1);
    printParseTree(root->right, depth + 1);
}


void freeTree(Node* root) {
    if (!root) return;
    freeTree(root->left);
    freeTree(root->right);
    free(root);
}

void yyerror(const char *s) {
    printf("\nEntered arithmetic expression is Invalid\n\n");
    flag = 1;
}

int main() {
    printf("Enter Any Arithmetic Expression which can have operations Addition, Subtraction, Multiplication, Division, Modulus and Round brackets:\n");

    yyparse();

    if (flag == 0 && root != NULL) {
        printf("\nResult = %d\n", root->val);
        printf("\nEntered arithmetic expression is Valid\n");
        printf("\nParse Tree\n===========================================\n");
        printParseTree(root, 0);
    }

    freeTree(root);
    return 0;
}

//input
1+2

//steps to run
flex ass7.l     
bison -d ass7.y
gcc -o ass7 ass7.tab.c lex.yy.c 
./ass7         

//expression evaluation expression 

//lex.l
%{
#include <stdio.h>
#include <stdlib.h>
#include "parer.tab.h"
%}

%%

finish      { return FINISH; }
[a-zA-Z_][a-zA-Z0-9_]*   { yylval.sval = strdup(yytext); return IDENTIFIER; }
[0-9]+      { yylval.val = atoi(yytext); return NUMBER; }
"="         { return '='; }
[\n]        { return '\n'; }
[\t ]+      ; // Ignore whitespace
.           { return yytext[0]; }

%%

int yywrap() { return 1; } 

//parser.y
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Parse tree node
typedef struct Node {
    char *label;
    int val;
    struct Node *left, *right;
} Node;

Node* make_node(const char* label, int val, Node* left, Node* right);
void print_tree(Node* node, const char* prefix, int is_left);
void free_tree(Node* node);

int symtab[26]; // For variables a-z

%}

%union {
    int val;
    char* sval;
    struct Node* node;
}

%token <val> NUMBER
%token <sval> IDENTIFIER
%token FINISH

%type <node> expr
%type <node> stmt

%%

input:
      /* empty */
    | input stmt '\n'   {
        print_tree($2, "", -1);
        if ($2->label[0] == '=') {
            printf("result: %s = %d\n", $2->left->label, $2->right->val);
        }
        free_tree($2);
    }
    | input FINISH      { printf("result: c=%d\n", symtab['c'-'a']); exit(0); }
    ;

stmt:
    IDENTIFIER '=' expr {
        symtab[$1[0]-'a'] = $3->val;
        Node* var = make_node($1, $3->val, NULL, NULL);
        $$ = make_node("=", $3->val, var, $3);
        free($1);
    }
    | expr { $$ = $1; }
    ;

expr:
    expr '+' expr {
        $$ = make_node("+", $1->val + $3->val, $1, $3);
    }
    | expr '-' expr {
        $$ = make_node("-", $1->val - $3->val, $1, $3);
    }
    | expr '*' expr {
        $$ = make_node("*", $1->val * $3->val, $1, $3);
    }
    | expr '/' expr {
        $$ = make_node("/", $1->val / $3->val, $1, $3);
    }
    | '(' expr ')' { $$ = $2; }
    | NUMBER {
        char buf[32];
        sprintf(buf, "%d", $1);
        $$ = make_node(strdup(buf), $1, NULL, NULL);
    }
    | IDENTIFIER {
        int v = symtab[$1[0]-'a'];
        char buf[32];
        sprintf(buf, "%s=%d", $1, v);
        $$ = make_node(strdup(buf), v, NULL, NULL);
        free($1);
    }
    ;

%%

Node* make_node(const char* label, int val, Node* left, Node* right) {
    Node* n = (Node*)malloc(sizeof(Node));
    n->label = strdup(label);
    n->val = val;
    n->left = left;
    n->right = right;
    return n;
}

// Simple ASCII tree printer for compatibility
void print_tree(Node* node, const char* prefix, int is_left) {
    if (!node) return;
    printf("%s", prefix);
    if (is_left == -1) {
        printf("%s\n", node->label);
    } else if (is_left) {
        printf("|-- %s\n", node->label);
    } else {
        printf("+-- %s\n", node->label);
    }
    char new_prefix[256];
    strcpy(new_prefix, prefix);
    if (is_left == -1) {
        strcat(new_prefix, "");
    } else if (is_left) {
        strcat(new_prefix, "|   ");
    } else {
        strcat(new_prefix, "    ");
    }
    if (node->left && node->right) {
        print_tree(node->left, new_prefix, 1);
        print_tree(node->right, new_prefix, 0);
    } else if (node->left) {
        print_tree(node->left, new_prefix, 0);
    } else if (node->right) {
        print_tree(node->right, new_prefix, 0);
    }
}

void free_tree(Node* node) {
    if (!node) return;
    free_tree(node->left);
    free_tree(node->right);
    free(node->label);
    free(node);
}

int main() {
    printf("Enter expressions (end with 'finish'):\n");
    yyparse();
    return 0;
}

int yyerror(const char* s) {
    fprintf(stderr, "Error: %s\n", s);
    return 0;
} 

//steps to run
   bison -d parser.y
   flex lex.l
   gcc parser.tab.c lex.yy.c -o expr_eval.exe

//input ex:
a=1+2
b=a+2
c=a+b
finish


//code for name format email phone no

lex.l
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int line_number = 1;
%}

%%

[A-Z][a-z]+([[:space:]][A-Z][a-z]+)* { 
    printf("%-8d %-25s %-20s %s\n", line_number, yytext, "Valid Name", yytext); 
}

[0-9]{10} { 
    printf("%-8d %-25s %-20s %s\n", line_number, yytext, "Valid Mobile Number", yytext); 
}

(https?:\/\/)?(www\.)?[a-zA-Z0-9_-]+\.[a-zA-Z]+(\/[a-zA-Z0-9#_-]+)*\/? { 
    printf("%-8d %-25s %-20s %s\n", line_number, yytext, "Valid URL", yytext); 
}

[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,} { 
    printf("%-8d %-25s %-20s %s\n", line_number, yytext, "Valid Email", yytext); 
}

(0[1-9]|1[0-2])\/(0[1-9]|[12][0-9]|3[01])\/([0-9]{4}) { 
    printf("%-8d %-25s %-20s %s\n", line_number, yytext, "Valid Date", yytext); 
}

([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9] { 
    printf("%-8d %-25s %-20s %s\n", line_number, yytext, "Valid Time", yytext); 
}

[^ \t\n]+ { 
    printf("%-8d %-25s %-20s %s\n", line_number, yytext, "INVALID", yytext); 
}

\n { 
    line_number++; // Increment on each new line
}

%%

int main() {
    char filename[100];
    printf("Enter the input file name: ");
    scanf("%s", filename);

    FILE *file = fopen(filename, "r");
    if (!file) {
        printf("Could not open file: %s\n", filename);
        return 1;
    }

    printf("%-8s %-25s %-20s %s\n", "Line No", "Lexeme", "Token", "Token-Value");
    printf("----------------------------------------------------------------------------\n");

    yyin = file;
    yylex();
    fclose(file);
    return 0;
}
int yywrap() {
    return 1;
}


//input
John Doe
9876543210
https://www.example.com
user.name+test@example.com
12/25/2023
23:59:59
invalid@address@com
notAName
12345
www.test-site.org/page1
01/01/2020
00:00:00

//steps to run

//theory
ntroduction to Translators and Compilers
Programs written in high-level languages (like C++, Java, Python) are human-readable but cannot be directly executed by a computer's processor. They need to be translated into low-level machine code. This translation is performed by translator programs. The primary types include:

Compilers: A compiler is a program that translates an entire source program written in one language (the source language, typically high-level) into an equivalent program in another language (the target language, typically machine code for a specific processor or an intermediate virtual machine language like Java bytecode). The entire translation process is completed before the program is executed. The output is often a relocatable object file or an executable program. Compilers also report errors detected during translation.
Process: A high-level program on disk is loaded into memory. The compiler translates the whole program into a machine-code program, which is then saved to disk or executed directly.
Advantages: The generated machine code executes quickly because translation is done only once. The compiler doesn't need to be present during execution.
Disadvantages: The initial compilation process can be slow as the entire program must be translated. Compilers are often large and complex pieces of software.
Interpreters: An interpreter directly executes the operations specified in the source program, translating it line by line or statement by statement at runtime. It reads the source program and data, performs the operations, and produces output.
Process: A high-level program is loaded into memory. The interpreter translates and executes one instruction (or line) at a time.
Advantages: Often easier for learners and debugging, as errors can be reported immediately upon encountering them. Interpreted languages tend to be more portable across different platforms.
Disadvantages: Execution is generally slower than compiled code because translation happens during runtime. The interpreter program must remain in memory during execution. Examples include Python, Ruby, and Perl interpreters.
Assemblers: Translate assembly language programs (low-level symbolic code) into machine code. The output is typically an object file containing machine instructions and data placement information.
Preprocessors: Tools often considered part of the compiler that process the source code before the main compilation starts. They handle tasks like macro expansion (#define in C), file inclusion (#include), and conditional compilation.
Linkers: Programs that take multiple object files (produced by compilers or assemblers) and library files, combine them, resolve references between them (e.g., function calls across files), assign final memory addresses, and produce a single executable file.
Compiler Structure: Analysis and Synthesis
A compiler is conceptually divided into two major parts:

Analysis (Front-End): This part breaks down the source program into constituent pieces and imposes a grammatical structure on them. It uses this structure to create an intermediate representation (IR) of the source program. It also collects information about the source program and stores it in a data structure called a Symbol Table. The analysis phase focuses heavily on the rules of the source language and includes lexical analysis, syntax analysis, and semantic analysis. If errors are detected (lexical, syntax, semantic), this phase must report them.
Synthesis (Back-End): This part takes the intermediate representation and the symbol table generated by the analysis phase and constructs the desired target program. The synthesis phase often involves code optimization and code generation and is more dependent on the target machine architecture.
This structure allows for modularity; for instance, different front-ends for various source languages can target the same back-end for a specific machine.

Phases of Compilation
The compilation process typically involves six sequential phases. Symbol Table Management and Error Handling are crucial auxiliary components interacting with all phases.

Lexical Analysis (Scanning):

Input: Source program character stream.
Process: This is the first phase. It reads the input characters from left to right and groups them into meaningful sequences called lexemes. For each lexeme recognized, the lexical analyzer produces a token as output. A token typically consists of a token name (an abstract symbol representing a category like identifier, keyword, integer_constant) and an optional attribute value (e.g., a pointer to the symbol table entry for an identifier, or the numeric value of a constant). Patterns, usually specified by regular expressions, describe the structure of lexemes that can form a token. This phase also strips out whitespace (spaces, tabs, newlines) and comments. Information about identifiers encountered (like their names) is stored in the Symbol Table. To recognize tokens that might require looking beyond the current lexeme (e.g., distinguishing > from >=), the scanner often needs lookahead capabilities. Efficient input buffering techniques (like buffer pairs with sentinels) are used to manage reading characters and lookahead without excessive I/O operations. Finite Automata (NFAs and DFAs) are the theoretical models used to recognize patterns defined by regular expressions.
Output: A stream of tokens.
Errors Detected: Lexical Errors, including illegal characters in the input, identifiers or numeric constants exceeding language-defined limits, unterminated string or character literals, and unterminated comments. When the analyzer cannot match any pattern to a prefix of the remaining input, an error occurs.
Syntax Analysis (Parsing):

Input: Stream of tokens from the Lexical Analyzer.
Process: The parser attempts to group the tokens into hierarchical structures according to the syntax rules of the programming language, typically defined by a Context-Free Grammar (CFG). It verifies if the sequence of tokens can be generated by the grammar. This phase essentially checks the grammatical structure of the program. The parser usually constructs a parse tree (a detailed representation of how the input tokens derive from the grammar's start symbol)  or a more condensed Abstract Syntax Tree (AST) where nodes represent programming constructs. This phase handles the recursive structures defined in the grammar.
Output: A parse tree or AST representing the program's syntactic structure.
Errors Detected: Syntax Errors, occurring when the token stream violates the structural rules (grammar) of the language (e.g., missing semicolons, unbalanced parentheses, incorrect keyword usage in a statement).
Parser Types: Different strategies exist:
Top-Down Parsing: Construction starts at the root of the parse tree (the grammar's start symbol) and works downwards to produce a tree that matches the token stream. Can often be implemented easily by hand.
LL Parsing: Scans input Left-to-right, constructs a Leftmost derivation. These are predictive parsers, meaning they predict which production rule to use based on the current input token (and potentially k lookahead tokens - LL(k)). Recursive Descent is a common implementation technique where grammar non-terminals correspond to recursive procedures. Table-driven LL parsing uses an explicit stack and a parsing table. Handles a subset of CFGs but is relatively simple.
Bottom-Up Parsing: Construction starts from the leaves (tokens) and works upwards, grouping tokens according to grammar rules until the start symbol is reached. Known generally as Shift-Reduce parsing. Handles a larger class of grammars than LL methods and is typically implemented using parser generator tools.
LR Parsing: Scans input Left-to-right, constructs a Rightmost derivation in reverse. Very powerful, table-driven approach. Variants include:
SLR (Simple LR): Builds LR(0) states and uses FOLLOW sets to decide on reductions. Relatively simple tables, limited grammar scope compared to other LR types.
LALR (Look-Ahead LR): Merges LR(0) states having identical cores, using lookahead (usually 1 token) to resolve conflicts. Offers a good balance between parsing power (more than SLR) and table size (same number of states as SLR, much smaller than canonical LR). This is the method used by Yacc and Bison.
CLR (Canonical LR): The most powerful LR method, incorporating lookahead directly into the state items. Recognizes the largest class of LR grammars but often produces impractically large parsing tables.
Operator-Precedence Parsing: A simpler bottom-up technique suitable for expression grammars, using operator precedence and associativity rules to guide reductions.
Semantic Analysis:

Input: Parse Tree / AST.
Process: This phase checks the program for semantic correctness, ensuring the meaning is consistent with the language definition beyond just the grammatical structure. Key tasks include type checking (verifying that operators have operands of compatible types), scope checking (ensuring variables and functions are used according to visibility rules), and matching function calls with definitions (checking argument number and types). It gathers type information and enriches the AST or Symbol Table. Implicit type conversions (coercions), like converting an integer to a float in an expression, are often handled here.
Output: An annotated AST or equivalent representation, confirmed to be semantically valid.
Errors Detected: Semantic Errors, such as type mismatches (int x = "hello";), using undeclared variables, calling functions with wrong arguments, accessing private members improperly.
Intermediate Code Generation:

Input: Semantically verified annotated AST.
Process: Generates an explicit Intermediate Representation (IR) of the source program. The IR is typically low-level and machine-like but independent of the specific target architecture. It should be easy to produce and easy to translate into target machine code.
Output: Intermediate Code. Common forms include:
Three-Address Code: Sequences of instructions resembling assembly, where each instruction has at most one operator and usually three addresses (two operands, one result), often using temporary variables (e.g., t1 = id2 * 60, t2 = id1 + t1).
Syntax Trees: The AST itself can serve as IR.
Postfix Notation: Operator follows its operands.
Code Optimization:

Input: Intermediate Representation (IR).
Process: Analyzes and transforms the IR to make the resulting target code more efficient (faster, smaller, less power consumption) without altering the program's semantic meaning. This phase is often optional but crucial for producing high-performance code. Optimization can occur at the IR level (machine-independent) and later on the target code (machine-dependent). Key techniques include:
Common Subexpression Elimination: Detects when the same value is computed multiple times within a block of code and avoids re-computation by saving and reusing the first result. Example: In a = b*c + g; d = b*c * e;, the b*c part is computed once, stored in a temporary variable t1, and reused: t1 = b*c; a = t1 + g; d = t1 * e;.
Constant Folding: If all operands in an expression are constants known at compile time, the expression is evaluated, and the result replaces the expression directly in the code. For example, x = (2 + 3) * 10; becomes x = 50;.
Constant Propagation: If the compiler determines that a variable v will always hold a constant value c at a particular point, it replaces occurrences of v with c. This often enables further constant folding. For example, pi = 3.14; area = pi * r * r; becomes area = 3.14 * r * r;.
Dead Code Elimination: Removes code segments that are either impossible to reach during execution (e.g., code after an unconditional jump or return) or whose computed results are never used later in the program. This reduces code size and potentially improves execution speed by removing unnecessary operations.
Copy Propagation: After a direct assignment x = y;, this technique replaces later uses of x with y, provided neither x nor y has been reassigned in between. This can simplify code and potentially make the original assignment x = y become dead code.
Loop Optimizations: Techniques specifically target loops, such as Code Motion (moving calculations that produce the same result in every iteration - loop invariants - outside the loop) and Loop Fusion (merging adjacent loops that iterate over the same range into one).
Output: Optimized Intermediate Representation.
Code Generation:

Input: Optimized Intermediate Representation.
Process: This phase maps the IR onto the target machine's specific instruction set. It involves:
Instruction Selection: Choosing appropriate machine instructions for each IR operation.
Register Allocation: Assigning variables and temporary values to the limited number of CPU registers for fast access, spilling to memory when necessary.
Instruction Scheduling: Ordering instructions to maximize performance, considering processor pipelines and dependencies.
Output: Target machine code (often relocatable assembly language or binary machine code).
Supporting Components
Symbol Table Management: A crucial data structure, used across nearly all phases, that stores information about all identifiers (variables, functions, classes, constants, labels, etc.) encountered in the source code. Entries typically include the identifier's name, type, scope, memory location, and other relevant attributes. It allows the compiler to efficiently manage and retrieve information about identifiers.
Error Handling and Recovery:
Role: Interacts with all phases to detect errors. It must report errors clearly and meaningfully (often indicating the type of error and location - line/column). It may also attempt error recovery strategies to allow compilation to continue and potentially find more errors in a single compilation run, although the generated code may not be valid if errors were found.
Recovery Strategies: When an error is detected, the compiler needs strategies to resume processing. Common methods include:
Panic Mode Recovery: This is a simple and common strategy. When an error is found, the compiler discards input symbols (characters for the lexer, tokens for the parser) one at a time until a designated "synchronizing" token or element is found (e.g., a semicolon ; or closing brace } for the parser, or characters that can start a valid token for the lexer). Processing then resumes from that point.
Phrase-Level Recovery (Parser): The parser might attempt local correction on the remaining input, replacing a prefix with something that allows parsing to continue.
Error Productions (Parser): Grammar rules can be augmented with specific productions that match common errors.
Lexical-Level Corrections: For lexical errors, strategies might involve deleting an extraneous character, inserting a missing character, replacing an incorrect character, or transposing adjacent characters  to form a valid lexeme.
Lex/Flex and Yacc/Bison Tools
These are standard Unix tools (with modern open-source counterparts Flex and Bison) used for automating parts of compiler construction, specifically the front-end analysis phases.

Lex/Flex (.l files):

Purpose: Lex (and its faster, open-source version Flex) is a tool used to automatically generate a lexical analyzer (also called a scanner or lexer). It takes a specification file (.l) describing token patterns and generates C code (usually a function named yylex()) that performs lexical analysis.
Structure of .l file: Typically has three sections separated by %%:
Definitions Section: Contains C declarations (variables, includes like <stdio.h>), manifest constants (using %{ ... %}), and regular expression abbreviations (definitions).
Rules Section: Contains pairs of pattern { action }. The pattern is a regular expression, and the action is C code executed when the pattern is matched in the input.
User Code / Auxiliary Functions Section: Contains additional C functions needed by the actions, including potentially a main() function (if not using Yacc) and often a yywrap() function.
Key Functions/Variables:
yylex(): The primary function generated by Lex/Flex. When called, it scans the input stream (yyin) and returns the token code for the next lexeme found. It repeats until the input ends.
yytext: A character pointer (or array) holding the actual lexeme (the matched text).
yyleng: An integer holding the length of the matched lexeme (yytext).
yyin: The input file pointer (default is standard input). Can be set to read from a file.
yyout: The output file pointer (default is standard output).
yywrap(): Called by yylex() when it reaches the end of the input file. If yywrap() returns 1, scanning terminates. If it returns 0, yylex() assumes yyin has been pointed to a new file and continues scanning.
Yacc/Bison (.y files):

Purpose: Yacc (Yet Another Compiler-Compiler) and its GNU replacement Bison are tools used to automatically generate a parser based on a formal grammar specification. They take a specification file (.y) describing the language's grammar rules and generate C code (usually a function named yyparse()) that performs syntax analysis. They are typically used in conjunction with Lex/Flex.
Structure of .y file: Similar to Lex, it has three sections separated by %%:
Declarations Section: Contains C declarations (%{ ... %}), terminal symbol (token) declarations (%token), operator precedence and associativity declarations (%left, %right, %nonassoc), and type definitions for semantic values (%union).
Rules Section: Contains context-free grammar rules in a format similar to BNF, associating semantic actions (C code in {...}) with each rule.
User Code Section: Contains additional C functions, such as main(), the required yyerror() function for reporting syntax errors, and potentially the yylex() function itself if not generated by Lex.
Key Functions/Variables/Directives:
yyparse(): The main function generated by Yacc/Bison. It calls yylex() to get tokens and attempts to parse the token stream according to the grammar rules. It returns 0 for success and non-zero for failure. It typically uses a stack and a parsing table (often for LALR parsing).
yylex(): The lexical analyzer function (usually generated by Lex/Flex) called by yyparse() to get the next token.
yyerror(const char *s): A function you must provide in the C code section. It is called by yyparse() when a syntax error is detected. s is typically an error message string (like "syntax error").
yylval: A global variable (often a union type defined by %union) used by yylex() to pass the semantic value (attribute) associated with a token back to yyparse().
yytext, yyleng: Usually used within yylex() (from Lex) but might be referenced if yylex is defined within the .y file.
%token NAME ...: Declares terminal symbols (tokens) expected from yylex(). Can optionally specify the type of the associated yylval value (e.g., %token <num> INTEGER).
%type <type> nonterminal: Declares the data type for the semantic value of a non-terminal symbol.
%%: Separates the sections of the .y file.
Grammar Rules: Defined like nonterminal : symbol symbol ... { action } ;.
Actions ({...}): C code executed when a rule is reduced (recognized) by the parser. Inside actions:
$$: Refers to the semantic value of the non-terminal on the left-hand side of the rule.
$1, $2, etc.: Refer to the semantic values of the symbols on the right-hand side of the rule, numbered from left to right.
Interaction: yyparse() (from Yacc/Bison) calls yylex() (from Lex/Flex) to get tokens. yylex() returns token codes and puts semantic values in yylval. yyparse() uses the codes and values according to the grammar rules. A shared header file (often generated by bison -d) typically defines the token codes.

Alternatives: While Flex and Bison are traditional and widespread, other tools exist: ANTLR (generates both lexer and parser, often LL(*)), JavaCC, Coco/R, Ragel, re2c, PLY (Python Lex-Yacc).

Common Questions about Lex/Yacc Code
Structure: Describe the different sections of a .l (Lex/Flex) file and their purpose. Describe the different sections of a .y (Yacc/Bison) file and their purpose. What is the role of the %% separator?
Interaction: How do Lex/Flex and Yacc/Bison work together? (yylex() called by yyparse()). How is data (semantic value) passed from the lexer to the parser? (Via yylval). How are tokens declared and shared between Lex and Yacc? (Using %token in Yacc, returning codes in Lex, often via a shared header generated by bison -d).
Functions & Variables: What does yylex() do? What does it return? What does yyparse() do? What does it return? What is the purpose of yytext and yyleng? What is yylval used for? How is its type defined? What is the role of yywrap()? What must the user provide for yyerror()?
Rules & Actions: How do you define tokens using regular expressions in Lex? How do you define grammar rules in Yacc? What do $$, $1, $2, etc., mean in Yacc actions? How is operator precedence and associativity defined in Yacc (%left, %right)? Why is it important? How are conflicts (shift/reduce, reduce/reduce) resolved in Yacc/Bison?
Debugging/Usage: How would you debug a Lex/Yacc program? (Using printf in actions, Bison debug options like -t). Explain the typical compilation steps involving flex, bison -d, and gcc. What kind of errors does Lex detect vs. Yacc? (Lexical vs. Synt
